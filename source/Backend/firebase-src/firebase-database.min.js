/* eslint-disable */
import {
    getApp,
    _getProvider,
    _registerComponent,
    registerVersion,
    SDK_VERSION as SDK_VERSION$1,
} from './firebase-app.min.js';
const CONSTANTS = {
        NODE_CLIENT: !1,
        NODE_ADMIN: !1,
        SDK_VERSION: '${JSCORE_VERSION}',
    },
    assert = function (e, t) {
        if (!e) throw assertionError(t);
    },
    assertionError = function (e) {
        return new Error(
            'Firebase Database (' +
                CONSTANTS.SDK_VERSION +
                ') INTERNAL ASSERT FAILED: ' +
                e
        );
    },
    stringToByteArray$1 = function (n) {
        const r = [];
        let i = 0;
        for (let t = 0; t < n.length; t++) {
            let e = n.charCodeAt(t);
            e < 128
                ? (r[i++] = e)
                : (e < 2048
                      ? (r[i++] = (e >> 6) | 192)
                      : (55296 == (64512 & e) &&
                        t + 1 < n.length &&
                        56320 == (64512 & n.charCodeAt(t + 1))
                            ? ((e =
                                  65536 +
                                  ((1023 & e) << 10) +
                                  (1023 & n.charCodeAt(++t))),
                              (r[i++] = (e >> 18) | 240),
                              (r[i++] = ((e >> 12) & 63) | 128))
                            : (r[i++] = (e >> 12) | 224),
                        (r[i++] = ((e >> 6) & 63) | 128)),
                  (r[i++] = (63 & e) | 128));
        }
        return r;
    },
    byteArrayToString = function (e) {
        const t = [];
        let n = 0,
            r = 0;
        for (; n < e.length; ) {
            var i,
                o,
                s = e[n++];
            s < 128
                ? (t[r++] = String.fromCharCode(s))
                : 191 < s && s < 224
                ? ((i = e[n++]),
                  (t[r++] = String.fromCharCode(((31 & s) << 6) | (63 & i))))
                : 239 < s && s < 365
                ? ((o =
                      (((7 & s) << 18) |
                          ((63 & e[n++]) << 12) |
                          ((63 & e[n++]) << 6) |
                          (63 & e[n++])) -
                      65536),
                  (t[r++] = String.fromCharCode(55296 + (o >> 10))),
                  (t[r++] = String.fromCharCode(56320 + (1023 & o))))
                : ((i = e[n++]),
                  (o = e[n++]),
                  (t[r++] = String.fromCharCode(
                      ((15 & s) << 12) | ((63 & i) << 6) | (63 & o)
                  )));
        }
        return t.join('');
    },
    base64 = {
        byteToCharMap_: null,
        charToByteMap_: null,
        byteToCharMapWebSafe_: null,
        charToByteMapWebSafe_: null,
        ENCODED_VALS_BASE:
            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
        get ENCODED_VALS() {
            return this.ENCODED_VALS_BASE + '+/=';
        },
        get ENCODED_VALS_WEBSAFE() {
            return this.ENCODED_VALS_BASE + '-_.';
        },
        HAS_NATIVE_SUPPORT: 'function' == typeof atob,
        encodeByteArray(r, e) {
            if (!Array.isArray(r))
                throw Error('encodeByteArray takes an array as a parameter');
            this.init_();
            var i = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
            const o = [];
            for (let n = 0; n < r.length; n += 3) {
                var s = r[n],
                    a = n + 1 < r.length,
                    l = a ? r[n + 1] : 0,
                    h = n + 2 < r.length,
                    c = h ? r[n + 2] : 0;
                let e = ((15 & l) << 2) | (c >> 6),
                    t = 63 & c;
                h || ((t = 64), a || (e = 64)),
                    o.push(i[s >> 2], i[((3 & s) << 4) | (l >> 4)], i[e], i[t]);
            }
            return o.join('');
        },
        encodeString(e, t) {
            return this.HAS_NATIVE_SUPPORT && !t
                ? btoa(e)
                : this.encodeByteArray(stringToByteArray$1(e), t);
        },
        decodeString(e, t) {
            return this.HAS_NATIVE_SUPPORT && !t
                ? atob(e)
                : byteArrayToString(this.decodeStringToByteArray(e, t));
        },
        decodeStringToByteArray(t, e) {
            this.init_();
            var n = e ? this.charToByteMapWebSafe_ : this.charToByteMap_;
            const r = [];
            for (let e = 0; e < t.length; ) {
                var i = n[t.charAt(e++)],
                    o = e < t.length ? n[t.charAt(e)] : 0;
                ++e;
                var s = e < t.length ? n[t.charAt(e)] : 64;
                ++e;
                var a = e < t.length ? n[t.charAt(e)] : 64;
                if ((++e, null == i || null == o || null == s || null == a))
                    throw Error();
                r.push((i << 2) | (o >> 4)),
                    64 !== s &&
                        (r.push(((o << 4) & 240) | (s >> 2)),
                        64 !== a && r.push(((s << 6) & 192) | a));
            }
            return r;
        },
        init_() {
            if (!this.byteToCharMap_) {
                (this.byteToCharMap_ = {}),
                    (this.charToByteMap_ = {}),
                    (this.byteToCharMapWebSafe_ = {}),
                    (this.charToByteMapWebSafe_ = {});
                for (let e = 0; e < this.ENCODED_VALS.length; e++)
                    (this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e)),
                        (this.charToByteMap_[this.byteToCharMap_[e]] = e),
                        (this.byteToCharMapWebSafe_[
                            e
                        ] = this.ENCODED_VALS_WEBSAFE.charAt(e)),
                        (this.charToByteMapWebSafe_[
                            this.byteToCharMapWebSafe_[e]
                        ] = e),
                        e >= this.ENCODED_VALS_BASE.length &&
                            ((this.charToByteMap_[
                                this.ENCODED_VALS_WEBSAFE.charAt(e)
                            ] = e),
                            (this.charToByteMapWebSafe_[
                                this.ENCODED_VALS.charAt(e)
                            ] = e));
            }
        },
    },
    base64Encode = function (e) {
        e = stringToByteArray$1(e);
        return base64.encodeByteArray(e, !0);
    },
    base64urlEncodeWithoutPadding = function (e) {
        return base64Encode(e).replace(/\./g, '');
    },
    base64Decode = function (e) {
        try {
            return base64.decodeString(e, !0);
        } catch (e) {
            console.error('base64Decode failed: ', e);
        }
        return null;
    };
function deepCopy(e) {
    return deepExtend(void 0, e);
}
function deepExtend(e, t) {
    if (!(t instanceof Object)) return t;
    switch (t.constructor) {
        case Date:
            const n = t;
            return new Date(n.getTime());
        case Object:
            void 0 === e && (e = {});
            break;
        case Array:
            e = [];
            break;
        default:
            return t;
    }
    for (const r in t)
        t.hasOwnProperty(r) &&
            isValidKey$1(r) &&
            (e[r] = deepExtend(e[r], t[r]));
    return e;
}
function isValidKey$1(e) {
    return '__proto__' !== e;
}
class Deferred {
    constructor() {
        (this.reject = () => {}),
            (this.resolve = () => {}),
            (this.promise = new Promise((e, t) => {
                (this.resolve = e), (this.reject = t);
            }));
    }
    wrapCallback(n) {
        return (e, t) => {
            e ? this.reject(e) : this.resolve(t),
                'function' == typeof n &&
                    (this.promise.catch(() => {}),
                    1 === n.length ? n(e) : n(e, t));
        };
    }
}
function createMockUserToken(e, t) {
    if (e.uid)
        throw new Error(
            'The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.'
        );
    var n = t || 'demo-project',
        r = e.iat || 0,
        t = e.sub || e.user_id;
    if (!t)
        throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
    e = Object.assign(
        {
            iss: `https://securetoken.google.com/${n}`,
            aud: n,
            iat: r,
            exp: r + 3600,
            auth_time: r,
            sub: t,
            user_id: t,
            firebase: { sign_in_provider: 'custom', identities: {} },
        },
        e
    );
    return [
        base64urlEncodeWithoutPadding(
            JSON.stringify({ alg: 'none', type: 'JWT' })
        ),
        base64urlEncodeWithoutPadding(JSON.stringify(e)),
        '',
    ].join('.');
}
function getUA() {
    return 'undefined' != typeof navigator &&
        'string' == typeof navigator.userAgent
        ? navigator.userAgent
        : '';
}
function isMobileCordova() {
    return (
        'undefined' != typeof window &&
        !!(window.cordova || window.phonegap || window.PhoneGap) &&
        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA())
    );
}
function isReactNative() {
    return 'object' == typeof navigator && 'ReactNative' === navigator.product;
}
function isNodeSdk() {
    return !0 === CONSTANTS.NODE_ADMIN;
}
function jsonEval(e) {
    return JSON.parse(e);
}
function stringify(e) {
    return JSON.stringify(e);
}
const decode = function (e) {
        let t = {},
            n = {},
            r = {},
            i = '';
        try {
            var o = e.split('.');
            (t = jsonEval(base64Decode(o[0]) || '')),
                (n = jsonEval(base64Decode(o[1]) || '')),
                (i = o[2]),
                (r = n.d || {}),
                delete n.d;
        } catch (e) {}
        return { header: t, claims: n, data: r, signature: i };
    },
    isValidFormat = function (e) {
        const t = decode(e),
            n = t.claims;
        return !!n && 'object' == typeof n && n.hasOwnProperty('iat');
    },
    isAdmin = function (e) {
        e = decode(e).claims;
        return 'object' == typeof e && !0 === e.admin;
    };
function contains(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
}
function safeGet(e, t) {
    if (Object.prototype.hasOwnProperty.call(e, t)) return e[t];
}
function isEmpty(e) {
    for (const t in e)
        if (Object.prototype.hasOwnProperty.call(e, t)) return !1;
    return !0;
}
function map(e, t, n) {
    const r = {};
    for (const i in e)
        Object.prototype.hasOwnProperty.call(e, i) &&
            (r[i] = t.call(n, e[i], i, e));
    return r;
}
function querystring(e) {
    const t = [];
    for (const [n, r] of Object.entries(e))
        Array.isArray(r)
            ? r.forEach((e) => {
                  t.push(encodeURIComponent(n) + '=' + encodeURIComponent(e));
              })
            : t.push(encodeURIComponent(n) + '=' + encodeURIComponent(r));
    return t.length ? '&' + t.join('&') : '';
}
class Sha1 {
    constructor() {
        (this.chain_ = []),
            (this.buf_ = []),
            (this.W_ = []),
            (this.pad_ = []),
            (this.inbuf_ = 0),
            (this.total_ = 0),
            (this.blockSize = 64),
            (this.pad_[0] = 128);
        for (let e = 1; e < this.blockSize; ++e) this.pad_[e] = 0;
        this.reset();
    }
    reset() {
        (this.chain_[0] = 1732584193),
            (this.chain_[1] = 4023233417),
            (this.chain_[2] = 2562383102),
            (this.chain_[3] = 271733878),
            (this.chain_[4] = 3285377520),
            (this.inbuf_ = 0),
            (this.total_ = 0);
    }
    compress_(t, n) {
        n = n || 0;
        const r = this.W_;
        if ('string' == typeof t)
            for (let e = 0; e < 16; e++)
                (r[e] =
                    (t.charCodeAt(n) << 24) |
                    (t.charCodeAt(n + 1) << 16) |
                    (t.charCodeAt(n + 2) << 8) |
                    t.charCodeAt(n + 3)),
                    (n += 4);
        else
            for (let e = 0; e < 16; e++)
                (r[e] =
                    (t[n] << 24) |
                    (t[n + 1] << 16) |
                    (t[n + 2] << 8) |
                    t[n + 3]),
                    (n += 4);
        for (let e = 16; e < 80; e++) {
            var i = r[e - 3] ^ r[e - 8] ^ r[e - 14] ^ r[e - 16];
            r[e] = 4294967295 & ((i << 1) | (i >>> 31));
        }
        let o = this.chain_[0],
            s = this.chain_[1],
            a = this.chain_[2],
            l = this.chain_[3],
            h = this.chain_[4],
            c,
            d;
        for (let e = 0; e < 80; e++) {
            d =
                e < 40
                    ? e < 20
                        ? ((c = l ^ (s & (a ^ l))), 1518500249)
                        : ((c = s ^ a ^ l), 1859775393)
                    : e < 60
                    ? ((c = (s & a) | (l & (s | a))), 2400959708)
                    : ((c = s ^ a ^ l), 3395469782);
            var u = (((o << 5) | (o >>> 27)) + c + h + d + r[e]) & 4294967295;
            (h = l),
                (l = a),
                (a = 4294967295 & ((s << 30) | (s >>> 2))),
                (s = o),
                (o = u);
        }
        (this.chain_[0] = (this.chain_[0] + o) & 4294967295),
            (this.chain_[1] = (this.chain_[1] + s) & 4294967295),
            (this.chain_[2] = (this.chain_[2] + a) & 4294967295),
            (this.chain_[3] = (this.chain_[3] + l) & 4294967295),
            (this.chain_[4] = (this.chain_[4] + h) & 4294967295);
    }
    update(n, r) {
        if (null != n) {
            var i = (r = void 0 === r ? n.length : r) - this.blockSize;
            let e = 0;
            const o = this.buf_;
            let t = this.inbuf_;
            for (; e < r; ) {
                if (0 === t)
                    for (; e <= i; )
                        this.compress_(n, e), (e += this.blockSize);
                if ('string' == typeof n) {
                    for (; e < r; )
                        if (
                            ((o[t] = n.charCodeAt(e)),
                            ++t,
                            ++e,
                            t === this.blockSize)
                        ) {
                            this.compress_(o), (t = 0);
                            break;
                        }
                } else
                    for (; e < r; )
                        if (((o[t] = n[e]), ++t, ++e, t === this.blockSize)) {
                            this.compress_(o), (t = 0);
                            break;
                        }
            }
            (this.inbuf_ = t), (this.total_ += r);
        }
    }
    digest() {
        const n = [];
        let t = 8 * this.total_;
        this.inbuf_ < 56
            ? this.update(this.pad_, 56 - this.inbuf_)
            : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        for (let e = this.blockSize - 1; 56 <= e; e--)
            (this.buf_[e] = 255 & t), (t /= 256);
        this.compress_(this.buf_);
        let r = 0;
        for (let t = 0; t < 5; t++)
            for (let e = 24; 0 <= e; e -= 8)
                (n[r] = (this.chain_[t] >> e) & 255), ++r;
        return n;
    }
}
function errorPrefix(e, t) {
    return `${e} failed: ${t} argument `;
}
const stringToByteArray = function (n) {
        const r = [];
        let i = 0;
        for (let t = 0; t < n.length; t++) {
            let e = n.charCodeAt(t);
            var o, s;
            55296 <= e &&
                e <= 56319 &&
                ((o = e - 55296),
                t++,
                assert(t < n.length, 'Surrogate pair missing trail surrogate.'),
                (s = n.charCodeAt(t) - 56320),
                (e = 65536 + (o << 10) + s)),
                e < 128
                    ? (r[i++] = e)
                    : (e < 2048
                          ? (r[i++] = (e >> 6) | 192)
                          : (e < 65536
                                ? (r[i++] = (e >> 12) | 224)
                                : ((r[i++] = (e >> 18) | 240),
                                  (r[i++] = ((e >> 12) & 63) | 128)),
                            (r[i++] = ((e >> 6) & 63) | 128)),
                      (r[i++] = (63 & e) | 128));
        }
        return r;
    },
    stringLength = function (t) {
        let n = 0;
        for (let e = 0; e < t.length; e++) {
            var r = t.charCodeAt(e);
            r < 128
                ? n++
                : r < 2048
                ? (n += 2)
                : 55296 <= r && r <= 56319
                ? ((n += 4), e++)
                : (n += 3);
        }
        return n;
    };
function getModularInstance(e) {
    return e && e._delegate ? e._delegate : e;
}
class Component {
    constructor(e, t, n) {
        (this.name = e),
            (this.instanceFactory = t),
            (this.type = n),
            (this.multipleInstances = !1),
            (this.serviceProps = {}),
            (this.instantiationMode = 'LAZY'),
            (this.onInstanceCreated = null);
    }
    setInstantiationMode(e) {
        return (this.instantiationMode = e), this;
    }
    setMultipleInstances(e) {
        return (this.multipleInstances = e), this;
    }
    setServiceProps(e) {
        return (this.serviceProps = e), this;
    }
    setInstanceCreatedCallback(e) {
        return (this.onInstanceCreated = e), this;
    }
}
var LogLevel, OperationType;
!(function (e) {
    (e[(e.DEBUG = 0)] = 'DEBUG'),
        (e[(e.VERBOSE = 1)] = 'VERBOSE'),
        (e[(e.INFO = 2)] = 'INFO'),
        (e[(e.WARN = 3)] = 'WARN'),
        (e[(e.ERROR = 4)] = 'ERROR'),
        (e[(e.SILENT = 5)] = 'SILENT');
})((LogLevel = LogLevel || {}));
const levelStringToEnum = {
        debug: LogLevel.DEBUG,
        verbose: LogLevel.VERBOSE,
        info: LogLevel.INFO,
        warn: LogLevel.WARN,
        error: LogLevel.ERROR,
        silent: LogLevel.SILENT,
    },
    defaultLogLevel = LogLevel.INFO,
    ConsoleMethod = {
        [LogLevel.DEBUG]: 'log',
        [LogLevel.VERBOSE]: 'log',
        [LogLevel.INFO]: 'info',
        [LogLevel.WARN]: 'warn',
        [LogLevel.ERROR]: 'error',
    },
    defaultLogHandler = (e, t, ...n) => {
        if (!(t < e.logLevel)) {
            var r = new Date().toISOString(),
                i = ConsoleMethod[t];
            if (!i)
                throw new Error(
                    `Attempted to log a message with an invalid logType (value: ${t})`
                );
            console[i](`[${r}]  ${e.name}:`, ...n);
        }
    };
class Logger {
    constructor(e) {
        (this.name = e),
            (this._logLevel = defaultLogLevel),
            (this._logHandler = defaultLogHandler),
            (this._userLogHandler = null);
    }
    get logLevel() {
        return this._logLevel;
    }
    set logLevel(e) {
        if (!(e in LogLevel))
            throw new TypeError(
                `Invalid value "${e}" assigned to \`logLevel\``
            );
        this._logLevel = e;
    }
    setLogLevel(e) {
        this._logLevel = 'string' == typeof e ? levelStringToEnum[e] : e;
    }
    get logHandler() {
        return this._logHandler;
    }
    set logHandler(e) {
        if ('function' != typeof e)
            throw new TypeError(
                'Value assigned to `logHandler` must be a function'
            );
        this._logHandler = e;
    }
    get userLogHandler() {
        return this._userLogHandler;
    }
    set userLogHandler(e) {
        this._userLogHandler = e;
    }
    debug(...e) {
        this._userLogHandler &&
            this._userLogHandler(this, LogLevel.DEBUG, ...e),
            this._logHandler(this, LogLevel.DEBUG, ...e);
    }
    log(...e) {
        this._userLogHandler &&
            this._userLogHandler(this, LogLevel.VERBOSE, ...e),
            this._logHandler(this, LogLevel.VERBOSE, ...e);
    }
    info(...e) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...e),
            this._logHandler(this, LogLevel.INFO, ...e);
    }
    warn(...e) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...e),
            this._logHandler(this, LogLevel.WARN, ...e);
    }
    error(...e) {
        this._userLogHandler &&
            this._userLogHandler(this, LogLevel.ERROR, ...e),
            this._logHandler(this, LogLevel.ERROR, ...e);
    }
}
const name = '@firebase/database',
    version = '0.12.5';
let SDK_VERSION = '';
function setSDKVersion(e) {
    SDK_VERSION = e;
}
class DOMStorageWrapper {
    constructor(e) {
        (this.domStorage_ = e), (this.prefix_ = 'firebase:');
    }
    set(e, t) {
        null == t
            ? this.domStorage_.removeItem(this.prefixedName_(e))
            : this.domStorage_.setItem(this.prefixedName_(e), stringify(t));
    }
    get(e) {
        e = this.domStorage_.getItem(this.prefixedName_(e));
        return null == e ? null : jsonEval(e);
    }
    remove(e) {
        this.domStorage_.removeItem(this.prefixedName_(e));
    }
    prefixedName_(e) {
        return this.prefix_ + e;
    }
    toString() {
        return this.domStorage_.toString();
    }
}
class MemoryStorage {
    constructor() {
        (this.cache_ = {}), (this.isInMemoryStorage = !0);
    }
    set(e, t) {
        null == t ? delete this.cache_[e] : (this.cache_[e] = t);
    }
    get(e) {
        return contains(this.cache_, e) ? this.cache_[e] : null;
    }
    remove(e) {
        delete this.cache_[e];
    }
}
const createStoragefor = function (e) {
        try {
            if ('undefined' != typeof window && void 0 !== window[e]) {
                const t = window[e];
                return (
                    t.setItem('firebase:sentinel', 'cache'),
                    t.removeItem('firebase:sentinel'),
                    new DOMStorageWrapper(t)
                );
            }
        } catch (e) {}
        return new MemoryStorage();
    },
    PersistentStorage = createStoragefor('localStorage'),
    SessionStorage = createStoragefor('sessionStorage'),
    logClient = new Logger('@firebase/database'),
    LUIDGenerator = (function () {
        let e = 1;
        return function () {
            return e++;
        };
    })(),
    sha1 = function (e) {
        e = stringToByteArray(e);
        const t = new Sha1();
        t.update(e);
        e = t.digest();
        return base64.encodeByteArray(e);
    },
    buildLogMessage_ = function (...t) {
        let n = '';
        for (let e = 0; e < t.length; e++) {
            var r = t[e];
            Array.isArray(r) ||
            (r && 'object' == typeof r && 'number' == typeof r.length)
                ? (n += buildLogMessage_.apply(null, r))
                : (n += 'object' == typeof r ? stringify(r) : r),
                (n += ' ');
        }
        return n;
    };
let logger = null,
    firstLog_ = !0;
const enableLogging$1 = function (e, t) {
        assert(
            !t || !0 === e || !1 === e,
            "Can't turn on custom loggers persistently."
        ),
            !0 === e
                ? ((logClient.logLevel = LogLevel.VERBOSE),
                  (logger = logClient.log.bind(logClient)),
                  t && SessionStorage.set('logging_enabled', !0))
                : 'function' == typeof e
                ? (logger = e)
                : ((logger = null), SessionStorage.remove('logging_enabled'));
    },
    log = function (...e) {
        !0 === firstLog_ &&
            ((firstLog_ = !1),
            null === logger &&
                !0 === SessionStorage.get('logging_enabled') &&
                enableLogging$1(!0)),
            logger && ((e = buildLogMessage_.apply(null, e)), logger(e));
    },
    logWrapper = function (t) {
        return function (...e) {
            log(t, ...e);
        };
    },
    error = function (...e) {
        e = 'FIREBASE INTERNAL ERROR: ' + buildLogMessage_(...e);
        logClient.error(e);
    },
    fatal = function (...e) {
        e = `FIREBASE FATAL ERROR: ${buildLogMessage_(...e)}`;
        throw (logClient.error(e), new Error(e));
    },
    warn = function (...e) {
        e = 'FIREBASE WARNING: ' + buildLogMessage_(...e);
        logClient.warn(e);
    },
    warnIfPageIsSecure = function () {
        'undefined' != typeof window &&
            window.location &&
            window.location.protocol &&
            -1 !== window.location.protocol.indexOf('https:') &&
            warn(
                'Insecure Firebase access from a secure page. Please use https in calls to new Firebase().'
            );
    },
    isInvalidJSONNumber = function (e) {
        return (
            'number' == typeof e &&
            (e != e ||
                e === Number.POSITIVE_INFINITY ||
                e === Number.NEGATIVE_INFINITY)
        );
    },
    executeWhenDOMReady = function (t) {
        if ('complete' === document.readyState) t();
        else {
            let e = !1;
            const n = function () {
                document.body
                    ? e || ((e = !0), t())
                    : setTimeout(n, Math.floor(10));
            };
            document.addEventListener
                ? (document.addEventListener('DOMContentLoaded', n, !1),
                  window.addEventListener('load', n, !1))
                : document.attachEvent &&
                  (document.attachEvent('onreadystatechange', () => {
                      'complete' === document.readyState && n();
                  }),
                  window.attachEvent('onload', n));
        }
    },
    MIN_NAME = '[MIN_NAME]',
    MAX_NAME = '[MAX_NAME]',
    nameCompare = function (e, t) {
        if (e === t) return 0;
        if (e === MIN_NAME || t === MAX_NAME) return -1;
        if (t === MIN_NAME || e === MAX_NAME) return 1;
        var n = tryParseInt(e),
            r = tryParseInt(t);
        return null !== n
            ? null !== r
                ? n - r == 0
                    ? e.length - t.length
                    : n - r
                : -1
            : null === r && e < t
            ? -1
            : 1;
    },
    stringCompare = function (e, t) {
        return e === t ? 0 : e < t ? -1 : 1;
    },
    requireKey = function (e, t) {
        if (t && e in t) return t[e];
        throw new Error(
            'Missing required key (' + e + ') in object: ' + stringify(t)
        );
    },
    ObjectToUniqueKey = function (t) {
        if ('object' != typeof t || null === t) return stringify(t);
        const n = [];
        for (const e in t) n.push(e);
        n.sort();
        let r = '{';
        for (let e = 0; e < n.length; e++)
            0 !== e && (r += ','),
                (r += stringify(n[e])),
                (r += ':'),
                (r += ObjectToUniqueKey(t[n[e]]));
        return (r += '}'), r;
    },
    splitStringBySize = function (t, n) {
        var r = t.length;
        if (r <= n) return [t];
        const i = [];
        for (let e = 0; e < r; e += n)
            e + n > r
                ? i.push(t.substring(e, r))
                : i.push(t.substring(e, e + n));
        return i;
    };
function each(e, t) {
    for (const n in e) e.hasOwnProperty(n) && t(n, e[n]);
}
const doubleToIEEE754String = function (e) {
        assert(!isInvalidJSONNumber(e), 'Invalid JSON number');
        let t, n, r, i, o;
        0 === e
            ? ((n = 0), (r = 0), (t = 1 / e == -1 / 0 ? 1 : 0))
            : ((t = e < 0),
              (e = Math.abs(e)),
              (r =
                  e >= Math.pow(2, -1022)
                      ? ((i = Math.min(
                            Math.floor(Math.log(e) / Math.LN2),
                            1023
                        )),
                        (n = i + 1023),
                        Math.round(e * Math.pow(2, 52 - i) - Math.pow(2, 52)))
                      : ((n = 0), Math.round(e / Math.pow(2, -1074)))));
        const s = [];
        for (o = 52; o; --o) s.push(r % 2 ? 1 : 0), (r = Math.floor(r / 2));
        for (o = 11; o; --o) s.push(n % 2 ? 1 : 0), (n = Math.floor(n / 2));
        s.push(t ? 1 : 0), s.reverse();
        const a = s.join('');
        let l = '';
        for (o = 0; o < 64; o += 8) {
            let e = parseInt(a.substr(o, 8), 2).toString(16);
            1 === e.length && (e = '0' + e), (l += e);
        }
        return l.toLowerCase();
    },
    isChromeExtensionContentScript = function () {
        return !(
            'object' != typeof window ||
            !window.chrome ||
            !window.chrome.extension ||
            /^chrome/.test(window.location.href)
        );
    },
    isWindowsStoreApp = function () {
        return 'object' == typeof Windows && 'object' == typeof Windows.UI;
    };
function errorForServerCode(e, t) {
    let n = 'Unknown Error';
    'too_big' === e
        ? (n =
              'The data requested exceeds the maximum size that can be accessed with a single request.')
        : 'permission_denied' === e
        ? (n = "Client doesn't have permission to access the desired data.")
        : 'unavailable' === e && (n = 'The service is unavailable');
    const r = new Error(e + ' at ' + t._path.toString() + ': ' + n);
    return (r.code = e.toUpperCase()), r;
}
const INTEGER_REGEXP_ = new RegExp('^-?(0*)\\d{1,10}$'),
    INTEGER_32_MIN = -2147483648,
    INTEGER_32_MAX = 2147483647,
    tryParseInt = function (e) {
        if (INTEGER_REGEXP_.test(e)) {
            e = Number(e);
            if (e >= INTEGER_32_MIN && e <= INTEGER_32_MAX) return e;
        }
        return null;
    },
    exceptionGuard = function (e) {
        try {
            e();
        } catch (t) {
            setTimeout(() => {
                var e = t.stack || '';
                throw (warn('Exception was thrown by user callback.', e), t);
            }, Math.floor(0));
        }
    },
    beingCrawled = function () {
        const e =
            ('object' == typeof window &&
                window.navigator &&
                window.navigator.userAgent) ||
            '';
        return (
            0 <=
            e.search(
                /googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i
            )
        );
    },
    setTimeoutNonBlocking = function (e, t) {
        const n = setTimeout(e, t);
        return 'object' == typeof n && n.unref && n.unref(), n;
    };
class AppCheckTokenProvider {
    constructor(e, t) {
        (this.appName_ = e),
            (this.appCheckProvider = t),
            (this.appCheck =
                null == t ? void 0 : t.getImmediate({ optional: !0 })),
            this.appCheck ||
                (null != t && t.get().then((e) => (this.appCheck = e)));
    }
    getToken(n) {
        return this.appCheck
            ? this.appCheck.getToken(n)
            : new Promise((e, t) => {
                  setTimeout(() => {
                      this.appCheck ? this.getToken(n).then(e, t) : e(null);
                  }, 0);
              });
    }
    addTokenChangeListener(t) {
        var e;
        null !== (e = this.appCheckProvider) &&
            void 0 !== e &&
            e.get().then((e) => e.addTokenListener(t));
    }
    notifyForInvalidToken() {
        warn(
            `Provided AppCheck credentials for the app named "${this.appName_}" ` +
                'are invalid. This usually indicates your app was not initialized correctly.'
        );
    }
}
class FirebaseAuthTokenProvider {
    constructor(e, t, n) {
        (this.appName_ = e),
            (this.firebaseOptions_ = t),
            (this.authProvider_ = n),
            (this.auth_ = null),
            (this.auth_ = n.getImmediate({ optional: !0 })),
            this.auth_ || n.onInit((e) => (this.auth_ = e));
    }
    getToken(n) {
        return this.auth_
            ? this.auth_
                  .getToken(n)
                  .catch((e) =>
                      e && 'auth/token-not-initialized' === e.code
                          ? (log(
                                'Got auth/token-not-initialized error.  Treating as null token.'
                            ),
                            null)
                          : Promise.reject(e)
                  )
            : new Promise((e, t) => {
                  setTimeout(() => {
                      this.auth_ ? this.getToken(n).then(e, t) : e(null);
                  }, 0);
              });
    }
    addTokenChangeListener(t) {
        this.auth_
            ? this.auth_.addAuthTokenListener(t)
            : this.authProvider_.get().then((e) => e.addAuthTokenListener(t));
    }
    removeTokenChangeListener(t) {
        this.authProvider_.get().then((e) => e.removeAuthTokenListener(t));
    }
    notifyForInvalidToken() {
        let e =
            'Provided authentication credentials for the app named "' +
            this.appName_ +
            '" are invalid. This usually indicates your app was not initialized correctly. ';
        'credential' in this.firebaseOptions_
            ? (e +=
                  'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.')
            : 'serviceAccount' in this.firebaseOptions_
            ? (e +=
                  'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.')
            : (e +=
                  'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.'),
            warn(e);
    }
}
class EmulatorTokenProvider {
    constructor(e) {
        this.accessToken = e;
    }
    getToken(e) {
        return Promise.resolve({ accessToken: this.accessToken });
    }
    addTokenChangeListener(e) {
        e(this.accessToken);
    }
    removeTokenChangeListener(e) {}
    notifyForInvalidToken() {}
}
EmulatorTokenProvider.OWNER = 'owner';
const PROTOCOL_VERSION = '5',
    VERSION_PARAM = 'v',
    TRANSPORT_SESSION_PARAM = 's',
    REFERER_PARAM = 'r',
    FORGE_REF = 'f',
    FORGE_DOMAIN_RE = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/,
    LAST_SESSION_PARAM = 'ls',
    APPLICATION_ID_PARAM = 'p',
    APP_CHECK_TOKEN_PARAM = 'ac',
    WEBSOCKET = 'websocket',
    LONG_POLLING = 'long_polling';
class RepoInfo {
    constructor(e, t, n, r, i = !1, o = '', s = !1) {
        (this.secure = t),
            (this.namespace = n),
            (this.webSocketOnly = r),
            (this.nodeAdmin = i),
            (this.persistenceKey = o),
            (this.includeNamespaceInQueryParams = s),
            (this._host = e.toLowerCase()),
            (this._domain = this._host.substr(this._host.indexOf('.') + 1)),
            (this.internalHost =
                PersistentStorage.get('host:' + e) || this._host);
    }
    isCacheableHost() {
        return 's-' === this.internalHost.substr(0, 2);
    }
    isCustomHost() {
        return (
            'firebaseio.com' !== this._domain &&
            'firebaseio-demo.com' !== this._domain
        );
    }
    get host() {
        return this._host;
    }
    set host(e) {
        e !== this.internalHost &&
            ((this.internalHost = e),
            this.isCacheableHost() &&
                PersistentStorage.set('host:' + this._host, this.internalHost));
    }
    toString() {
        let e = this.toURLString();
        return this.persistenceKey && (e += '<' + this.persistenceKey + '>'), e;
    }
    toURLString() {
        var e = this.secure ? 'https://' : 'http://',
            t = this.includeNamespaceInQueryParams
                ? `?ns=${this.namespace}`
                : '';
        return `${e}${this.host}/${t}`;
    }
}
function repoInfoNeedsQueryParam(e) {
    return (
        e.host !== e.internalHost ||
        e.isCustomHost() ||
        e.includeNamespaceInQueryParams
    );
}
function repoInfoConnectionURL(e, t, n) {
    assert('string' == typeof t, 'typeof type must == string'),
        assert('object' == typeof n, 'typeof params must == object');
    let r;
    if (t === WEBSOCKET)
        r = (e.secure ? 'wss://' : 'ws://') + e.internalHost + '/.ws?';
    else {
        if (t !== LONG_POLLING)
            throw new Error('Unknown connection type: ' + t);
        r = (e.secure ? 'https://' : 'http://') + e.internalHost + '/.lp?';
    }
    repoInfoNeedsQueryParam(e) && (n.ns = e.namespace);
    const i = [];
    return (
        each(n, (e, t) => {
            i.push(e + '=' + t);
        }),
        r + i.join('&')
    );
}
class StatsCollection {
    constructor() {
        this.counters_ = {};
    }
    incrementCounter(e, t = 1) {
        contains(this.counters_, e) || (this.counters_[e] = 0),
            (this.counters_[e] += t);
    }
    get() {
        return deepCopy(this.counters_);
    }
}
const collections = {},
    reporters = {};
function statsManagerGetCollection(e) {
    e = e.toString();
    return (
        collections[e] || (collections[e] = new StatsCollection()),
        collections[e]
    );
}
function statsManagerGetOrCreateReporter(e, t) {
    e = e.toString();
    return reporters[e] || (reporters[e] = t()), reporters[e];
}
class PacketReceiver {
    constructor(e) {
        (this.onMessage_ = e),
            (this.pendingResponses = []),
            (this.currentResponseNum = 0),
            (this.closeAfterResponse = -1),
            (this.onClose = null);
    }
    closeAfter(e, t) {
        (this.closeAfterResponse = e),
            (this.onClose = t),
            this.closeAfterResponse < this.currentResponseNum &&
                (this.onClose(), (this.onClose = null));
    }
    handleResponse(e, t) {
        for (
            this.pendingResponses[e] = t;
            this.pendingResponses[this.currentResponseNum];

        ) {
            const n = this.pendingResponses[this.currentResponseNum];
            delete this.pendingResponses[this.currentResponseNum];
            for (let e = 0; e < n.length; ++e)
                n[e] &&
                    exceptionGuard(() => {
                        this.onMessage_(n[e]);
                    });
            if (this.currentResponseNum === this.closeAfterResponse) {
                this.onClose && (this.onClose(), (this.onClose = null));
                break;
            }
            this.currentResponseNum++;
        }
    }
}
const FIREBASE_LONGPOLL_START_PARAM = 'start',
    FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close',
    FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand',
    FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB',
    FIREBASE_LONGPOLL_ID_PARAM = 'id',
    FIREBASE_LONGPOLL_PW_PARAM = 'pw',
    FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser',
    FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb',
    FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg',
    FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts',
    FIREBASE_LONGPOLL_DATA_PARAM = 'd',
    FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe',
    MAX_URL_DATA_SIZE = 1870,
    SEG_HEADER_SIZE = 30,
    MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE,
    KEEPALIVE_REQUEST_INTERVAL = 25e3,
    LP_CONNECT_TIMEOUT = 3e4;
class BrowserPollConnection {
    constructor(e, t, n, r, i, o, s) {
        (this.connId = e),
            (this.repoInfo = t),
            (this.applicationId = n),
            (this.appCheckToken = r),
            (this.authToken = i),
            (this.transportSessionId = o),
            (this.lastSessionId = s),
            (this.bytesSent = 0),
            (this.bytesReceived = 0),
            (this.everConnected_ = !1),
            (this.log_ = logWrapper(e)),
            (this.stats_ = statsManagerGetCollection(t)),
            (this.urlFn = (e) => (
                this.appCheckToken &&
                    (e[APP_CHECK_TOKEN_PARAM] = this.appCheckToken),
                repoInfoConnectionURL(t, LONG_POLLING, e)
            ));
    }
    open(e, t) {
        (this.curSegmentNum = 0),
            (this.onDisconnect_ = t),
            (this.myPacketOrderer = new PacketReceiver(e)),
            (this.isClosed_ = !1),
            (this.connectTimeoutTimer_ = setTimeout(() => {
                this.log_('Timed out trying to connect.'),
                    this.onClosed_(),
                    (this.connectTimeoutTimer_ = null);
            }, Math.floor(LP_CONNECT_TIMEOUT))),
            executeWhenDOMReady(() => {
                if (!this.isClosed_) {
                    this.scriptTagHolder = new FirebaseIFrameScriptHolder(
                        (...e) => {
                            var [t, n, r] = e;
                            if (
                                (this.incrementIncomingBytes_(e),
                                this.scriptTagHolder)
                            )
                                if (
                                    (this.connectTimeoutTimer_ &&
                                        (clearTimeout(
                                            this.connectTimeoutTimer_
                                        ),
                                        (this.connectTimeoutTimer_ = null)),
                                    (this.everConnected_ = !0),
                                    t === FIREBASE_LONGPOLL_START_PARAM)
                                )
                                    (this.id = n), (this.password = r);
                                else {
                                    if (t !== FIREBASE_LONGPOLL_CLOSE_COMMAND)
                                        throw new Error(
                                            'Unrecognized command received: ' +
                                                t
                                        );
                                    n
                                        ? ((this.scriptTagHolder.sendNewPolls = !1),
                                          this.myPacketOrderer.closeAfter(
                                              n,
                                              () => {
                                                  this.onClosed_();
                                              }
                                          ))
                                        : this.onClosed_();
                                }
                        },
                        (...e) => {
                            var [t, n] = e;
                            this.incrementIncomingBytes_(e),
                                this.myPacketOrderer.handleResponse(t, n);
                        },
                        () => {
                            this.onClosed_();
                        },
                        this.urlFn
                    );
                    const t = {};
                    (t[FIREBASE_LONGPOLL_START_PARAM] = 't'),
                        (t[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(
                            1e8 * Math.random()
                        )),
                        this.scriptTagHolder.uniqueCallbackIdentifier &&
                            (t[
                                FIREBASE_LONGPOLL_CALLBACK_ID_PARAM
                            ] = this.scriptTagHolder.uniqueCallbackIdentifier),
                        (t[VERSION_PARAM] = PROTOCOL_VERSION),
                        this.transportSessionId &&
                            (t[
                                TRANSPORT_SESSION_PARAM
                            ] = this.transportSessionId),
                        this.lastSessionId &&
                            (t[LAST_SESSION_PARAM] = this.lastSessionId),
                        this.applicationId &&
                            (t[APPLICATION_ID_PARAM] = this.applicationId),
                        this.appCheckToken &&
                            (t[APP_CHECK_TOKEN_PARAM] = this.appCheckToken),
                        'undefined' != typeof location &&
                            location.hostname &&
                            FORGE_DOMAIN_RE.test(location.hostname) &&
                            (t[REFERER_PARAM] = FORGE_REF);
                    var e = this.urlFn(t);
                    this.log_('Connecting via long-poll to ' + e),
                        this.scriptTagHolder.addTag(e, () => {});
                }
            });
    }
    start() {
        this.scriptTagHolder.startLongPoll(this.id, this.password),
            this.addDisconnectPingFrame(this.id, this.password);
    }
    static forceAllow() {
        BrowserPollConnection.forceAllow_ = !0;
    }
    static forceDisallow() {
        BrowserPollConnection.forceDisallow_ = !0;
    }
    static isAvailable() {
        return (
            !!BrowserPollConnection.forceAllow_ ||
            (!BrowserPollConnection.forceDisallow_ &&
                'undefined' != typeof document &&
                null != document.createElement &&
                !isChromeExtensionContentScript() &&
                !isWindowsStoreApp())
        );
    }
    markConnectionHealthy() {}
    shutdown_() {
        (this.isClosed_ = !0),
            this.scriptTagHolder &&
                (this.scriptTagHolder.close(), (this.scriptTagHolder = null)),
            this.myDisconnFrame &&
                (document.body.removeChild(this.myDisconnFrame),
                (this.myDisconnFrame = null)),
            this.connectTimeoutTimer_ &&
                (clearTimeout(this.connectTimeoutTimer_),
                (this.connectTimeoutTimer_ = null));
    }
    onClosed_() {
        this.isClosed_ ||
            (this.log_('Longpoll is closing itself'),
            this.shutdown_(),
            this.onDisconnect_ &&
                (this.onDisconnect_(this.everConnected_),
                (this.onDisconnect_ = null)));
    }
    close() {
        this.isClosed_ ||
            (this.log_('Longpoll is being closed.'), this.shutdown_());
    }
    send(e) {
        e = stringify(e);
        (this.bytesSent += e.length),
            this.stats_.incrementCounter('bytes_sent', e.length);
        var e = base64Encode(e),
            t = splitStringBySize(e, MAX_PAYLOAD_SIZE);
        for (let e = 0; e < t.length; e++)
            this.scriptTagHolder.enqueueSegment(
                this.curSegmentNum,
                t.length,
                t[e]
            ),
                this.curSegmentNum++;
    }
    addDisconnectPingFrame(e, t) {
        this.myDisconnFrame = document.createElement('iframe');
        const n = {};
        (n[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't'),
            (n[FIREBASE_LONGPOLL_ID_PARAM] = e),
            (n[FIREBASE_LONGPOLL_PW_PARAM] = t),
            (this.myDisconnFrame.src = this.urlFn(n)),
            (this.myDisconnFrame.style.display = 'none'),
            document.body.appendChild(this.myDisconnFrame);
    }
    incrementIncomingBytes_(e) {
        e = stringify(e).length;
        (this.bytesReceived += e),
            this.stats_.incrementCounter('bytes_received', e);
    }
}
class FirebaseIFrameScriptHolder {
    constructor(t, n, e, r) {
        (this.onDisconnect = e),
            (this.urlFn = r),
            (this.outstandingRequests = new Set()),
            (this.pendingSegs = []),
            (this.currentSerial = Math.floor(1e8 * Math.random())),
            (this.sendNewPolls = !0);
        {
            (this.uniqueCallbackIdentifier = LUIDGenerator()),
                (window[
                    FIREBASE_LONGPOLL_COMMAND_CB_NAME +
                        this.uniqueCallbackIdentifier
                ] = t),
                (window[
                    FIREBASE_LONGPOLL_DATA_CB_NAME +
                        this.uniqueCallbackIdentifier
                ] = n),
                (this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_());
            let e = '';
            this.myIFrame.src &&
                'javascript:' ===
                    this.myIFrame.src.substr(0, 'javascript:'.length) &&
                ((i = document.domain),
                (e = '<script>document.domain="' + i + '";</script>'));
            var i = '<html><body>' + e + '</body></html>';
            try {
                this.myIFrame.doc.open(),
                    this.myIFrame.doc.write(i),
                    this.myIFrame.doc.close();
            } catch (e) {
                log('frame writing exception'), e.stack && log(e.stack), log(e);
            }
        }
    }
    static createIFrame_() {
        const t = document.createElement('iframe');
        if (((t.style.display = 'none'), !document.body))
            throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';
        document.body.appendChild(t);
        try {
            t.contentWindow.document || log('No IE domain setting required');
        } catch (e) {
            var n = document.domain;
            t.src =
                "javascript:void((function(){document.open();document.domain='" +
                n +
                "';document.close();})())";
        }
        return (
            t.contentDocument
                ? (t.doc = t.contentDocument)
                : t.contentWindow
                ? (t.doc = t.contentWindow.document)
                : t.document && (t.doc = t.document),
            t
        );
    }
    close() {
        (this.alive = !1),
            this.myIFrame &&
                ((this.myIFrame.doc.body.innerHTML = ''),
                setTimeout(() => {
                    null !== this.myIFrame &&
                        (document.body.removeChild(this.myIFrame),
                        (this.myIFrame = null));
                }, Math.floor(0)));
        const e = this.onDisconnect;
        e && ((this.onDisconnect = null), e());
    }
    startLongPoll(e, t) {
        for (
            this.myID = e, this.myPW = t, this.alive = !0;
            this.newRequest_();

        );
    }
    newRequest_() {
        if (
            this.alive &&
            this.sendNewPolls &&
            this.outstandingRequests.size <
                (0 < this.pendingSegs.length ? 2 : 1)
        ) {
            this.currentSerial++;
            const i = {};
            (i[FIREBASE_LONGPOLL_ID_PARAM] = this.myID),
                (i[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW),
                (i[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial);
            var n = this.urlFn(i);
            let e = '',
                t = 0;
            for (; 0 < this.pendingSegs.length; ) {
                if (
                    !(
                        this.pendingSegs[0].d.length +
                            SEG_HEADER_SIZE +
                            e.length <=
                        MAX_URL_DATA_SIZE
                    )
                )
                    break;
                var r = this.pendingSegs.shift();
                (e =
                    e +
                    '&' +
                    FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +
                    t +
                    '=' +
                    r.seg +
                    '&' +
                    FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +
                    t +
                    '=' +
                    r.ts +
                    '&' +
                    FIREBASE_LONGPOLL_DATA_PARAM +
                    t +
                    '=' +
                    r.d),
                    t++;
            }
            return (n += e), this.addLongPollTag_(n, this.currentSerial), !0;
        }
        return !1;
    }
    enqueueSegment(e, t, n) {
        this.pendingSegs.push({ seg: e, ts: t, d: n }),
            this.alive && this.newRequest_();
    }
    addLongPollTag_(e, t) {
        this.outstandingRequests.add(t);
        const n = () => {
                this.outstandingRequests.delete(t), this.newRequest_();
            },
            r = setTimeout(n, Math.floor(KEEPALIVE_REQUEST_INTERVAL));
        this.addTag(e, () => {
            clearTimeout(r), n();
        });
    }
    addTag(e, n) {
        setTimeout(() => {
            try {
                if (!this.sendNewPolls) return;
                const t = this.myIFrame.doc.createElement('script');
                (t.type = 'text/javascript'),
                    (t.async = !0),
                    (t.src = e),
                    (t.onload = t.onreadystatechange = function () {
                        var e = t.readyState;
                        (e && 'loaded' !== e && 'complete' !== e) ||
                            ((t.onload = t.onreadystatechange = null),
                            t.parentNode && t.parentNode.removeChild(t),
                            n());
                    }),
                    (t.onerror = () => {
                        log('Long-poll script failed to load: ' + e),
                            (this.sendNewPolls = !1),
                            this.close();
                    }),
                    this.myIFrame.doc.body.appendChild(t);
            } catch (e) {}
        }, Math.floor(1));
    }
}
const WEBSOCKET_MAX_FRAME_SIZE = 16384,
    WEBSOCKET_KEEPALIVE_INTERVAL = 45e3;
let WebSocketImpl = null;
'undefined' != typeof MozWebSocket
    ? (WebSocketImpl = MozWebSocket)
    : 'undefined' != typeof WebSocket && (WebSocketImpl = WebSocket);
class WebSocketConnection {
    constructor(e, t, n, r, i, o, s) {
        (this.connId = e),
            (this.applicationId = n),
            (this.appCheckToken = r),
            (this.authToken = i),
            (this.keepaliveTimer = null),
            (this.frames = null),
            (this.totalFrames = 0),
            (this.bytesSent = 0),
            (this.bytesReceived = 0),
            (this.log_ = logWrapper(this.connId)),
            (this.stats_ = statsManagerGetCollection(t)),
            (this.connURL = WebSocketConnection.connectionURL_(t, o, s, r)),
            (this.nodeAdmin = t.nodeAdmin);
    }
    static connectionURL_(e, t, n, r) {
        const i = {};
        return (
            (i[VERSION_PARAM] = PROTOCOL_VERSION),
            'undefined' != typeof location &&
                location.hostname &&
                FORGE_DOMAIN_RE.test(location.hostname) &&
                (i[REFERER_PARAM] = FORGE_REF),
            t && (i[TRANSPORT_SESSION_PARAM] = t),
            n && (i[LAST_SESSION_PARAM] = n),
            r && (i[APP_CHECK_TOKEN_PARAM] = r),
            repoInfoConnectionURL(e, WEBSOCKET, i)
        );
    }
    open(e, t) {
        (this.onDisconnect = t),
            (this.onMessage = e),
            this.log_('Websocket connecting to ' + this.connURL),
            (this.everConnected_ = !1),
            PersistentStorage.set('previous_websocket_failure', !0);
        try {
            isNodeSdk() ||
                ((n = {
                    headers: {
                        'X-Firebase-GMPID': this.applicationId || '',
                        'X-Firebase-AppCheck': this.appCheckToken || '',
                    },
                }),
                (this.mySock = new WebSocketImpl(this.connURL, [], n)));
        } catch (e) {
            this.log_('Error instantiating WebSocket.');
            var n = e.message || e.data;
            return n && this.log_(n), void this.onClosed_();
        }
        (this.mySock.onopen = () => {
            this.log_('Websocket connected.'), (this.everConnected_ = !0);
        }),
            (this.mySock.onclose = () => {
                this.log_('Websocket connection was disconnected.'),
                    (this.mySock = null),
                    this.onClosed_();
            }),
            (this.mySock.onmessage = (e) => {
                this.handleIncomingFrame(e);
            }),
            (this.mySock.onerror = (e) => {
                this.log_('WebSocket error.  Closing connection.');
                e = e.message || e.data;
                e && this.log_(e), this.onClosed_();
            });
    }
    start() {}
    static forceDisallow() {
        WebSocketConnection.forceDisallow_ = !0;
    }
    static isAvailable() {
        let e = !1;
        var t;
        return (
            'undefined' == typeof navigator ||
                !navigator.userAgent ||
                ((t = navigator.userAgent.match(
                    /Android ([0-9]{0,}\.[0-9]{0,})/
                )) &&
                    1 < t.length &&
                    parseFloat(t[1]) < 4.4 &&
                    (e = !0)),
            !e && null !== WebSocketImpl && !WebSocketConnection.forceDisallow_
        );
    }
    static previouslyFailed() {
        return (
            PersistentStorage.isInMemoryStorage ||
            !0 === PersistentStorage.get('previous_websocket_failure')
        );
    }
    markConnectionHealthy() {
        PersistentStorage.remove('previous_websocket_failure');
    }
    appendFrame_(e) {
        this.frames.push(e),
            this.frames.length === this.totalFrames &&
                ((e = this.frames.join('')),
                (this.frames = null),
                (e = jsonEval(e)),
                this.onMessage(e));
    }
    handleNewFrameCount_(e) {
        (this.totalFrames = e), (this.frames = []);
    }
    extractFrameCount_(e) {
        if (
            (assert(null === this.frames, 'We already have a frame buffer'),
            e.length <= 6)
        ) {
            var t = Number(e);
            if (!isNaN(t)) return this.handleNewFrameCount_(t), null;
        }
        return this.handleNewFrameCount_(1), e;
    }
    handleIncomingFrame(e) {
        null !== this.mySock &&
            ((e = e.data),
            (this.bytesReceived += e.length),
            this.stats_.incrementCounter('bytes_received', e.length),
            this.resetKeepAlive(),
            null !== this.frames
                ? this.appendFrame_(e)
                : null !== (e = this.extractFrameCount_(e)) &&
                  this.appendFrame_(e));
    }
    send(e) {
        this.resetKeepAlive();
        e = stringify(e);
        (this.bytesSent += e.length),
            this.stats_.incrementCounter('bytes_sent', e.length);
        var t = splitStringBySize(e, WEBSOCKET_MAX_FRAME_SIZE);
        1 < t.length && this.sendString_(String(t.length));
        for (let e = 0; e < t.length; e++) this.sendString_(t[e]);
    }
    shutdown_() {
        (this.isClosed_ = !0),
            this.keepaliveTimer &&
                (clearInterval(this.keepaliveTimer),
                (this.keepaliveTimer = null)),
            this.mySock && (this.mySock.close(), (this.mySock = null));
    }
    onClosed_() {
        this.isClosed_ ||
            (this.log_('WebSocket is closing itself'),
            this.shutdown_(),
            this.onDisconnect &&
                (this.onDisconnect(this.everConnected_),
                (this.onDisconnect = null)));
    }
    close() {
        this.isClosed_ ||
            (this.log_('WebSocket is being closed'), this.shutdown_());
    }
    resetKeepAlive() {
        clearInterval(this.keepaliveTimer),
            (this.keepaliveTimer = setInterval(() => {
                this.mySock && this.sendString_('0'), this.resetKeepAlive();
            }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL)));
    }
    sendString_(e) {
        try {
            this.mySock.send(e);
        } catch (e) {
            this.log_(
                'Exception thrown from WebSocket.send():',
                e.message || e.data,
                'Closing connection.'
            ),
                setTimeout(this.onClosed_.bind(this), 0);
        }
    }
}
(WebSocketConnection.responsesRequiredToBeHealthy = 2),
    (WebSocketConnection.healthyTimeout = 3e4);
class TransportManager {
    constructor(e) {
        this.initTransports_(e);
    }
    static get ALL_TRANSPORTS() {
        return [BrowserPollConnection, WebSocketConnection];
    }
    initTransports_(e) {
        var t = WebSocketConnection && WebSocketConnection.isAvailable();
        let n = t && !WebSocketConnection.previouslyFailed();
        if (
            (e.webSocketOnly &&
                (t ||
                    warn(
                        "wss:// URL used, but browser isn't known to support websockets.  Trying anyway."
                    ),
                (n = !0)),
            n)
        )
            this.transports_ = [WebSocketConnection];
        else {
            const r = (this.transports_ = []);
            for (const i of TransportManager.ALL_TRANSPORTS)
                i && i.isAvailable() && r.push(i);
        }
    }
    initialTransport() {
        if (0 < this.transports_.length) return this.transports_[0];
        throw new Error('No transports available');
    }
    upgradeTransport() {
        return 1 < this.transports_.length ? this.transports_[1] : null;
    }
}
const UPGRADE_TIMEOUT = 6e4,
    DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5e3,
    BYTES_SENT_HEALTHY_OVERRIDE = 10240,
    BYTES_RECEIVED_HEALTHY_OVERRIDE = 102400,
    MESSAGE_TYPE = 't',
    MESSAGE_DATA = 'd',
    CONTROL_SHUTDOWN = 's',
    CONTROL_RESET = 'r',
    CONTROL_ERROR = 'e',
    CONTROL_PONG = 'o',
    SWITCH_ACK = 'a',
    END_TRANSMISSION = 'n',
    PING = 'p',
    SERVER_HELLO = 'h';
class Connection {
    constructor(e, t, n, r, i, o, s, a, l, h) {
        (this.id = e),
            (this.repoInfo_ = t),
            (this.applicationId_ = n),
            (this.appCheckToken_ = r),
            (this.authToken_ = i),
            (this.onMessage_ = o),
            (this.onReady_ = s),
            (this.onDisconnect_ = a),
            (this.onKill_ = l),
            (this.lastSessionId = h),
            (this.connectionCount = 0),
            (this.pendingDataMessages = []),
            (this.state_ = 0),
            (this.log_ = logWrapper('c:' + this.id + ':')),
            (this.transportManager_ = new TransportManager(t)),
            this.log_('Connection created'),
            this.start_();
    }
    start_() {
        const e = this.transportManager_.initialTransport();
        (this.conn_ = new e(
            this.nextTransportId_(),
            this.repoInfo_,
            this.applicationId_,
            this.appCheckToken_,
            this.authToken_,
            null,
            this.lastSessionId
        )),
            (this.primaryResponsesRequired_ =
                e.responsesRequiredToBeHealthy || 0);
        const t = this.connReceiver_(this.conn_),
            n = this.disconnReceiver_(this.conn_);
        (this.tx_ = this.conn_),
            (this.rx_ = this.conn_),
            (this.secondaryConn_ = null),
            (this.isHealthy_ = !1),
            setTimeout(() => {
                this.conn_ && this.conn_.open(t, n);
            }, Math.floor(0));
        var r = e.healthyTimeout || 0;
        0 < r &&
            (this.healthyTimeout_ = setTimeoutNonBlocking(() => {
                (this.healthyTimeout_ = null),
                    this.isHealthy_ ||
                        (this.conn_ &&
                        this.conn_.bytesReceived >
                            BYTES_RECEIVED_HEALTHY_OVERRIDE
                            ? (this.log_(
                                  'Connection exceeded healthy timeout but has received ' +
                                      this.conn_.bytesReceived +
                                      ' bytes.  Marking connection healthy.'
                              ),
                              (this.isHealthy_ = !0),
                              this.conn_.markConnectionHealthy())
                            : this.conn_ &&
                              this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE
                            ? this.log_(
                                  'Connection exceeded healthy timeout but has sent ' +
                                      this.conn_.bytesSent +
                                      ' bytes.  Leaving connection alive.'
                              )
                            : (this.log_(
                                  'Closing unhealthy connection after timeout.'
                              ),
                              this.close()));
            }, Math.floor(r)));
    }
    nextTransportId_() {
        return 'c:' + this.id + ':' + this.connectionCount++;
    }
    disconnReceiver_(t) {
        return (e) => {
            t === this.conn_
                ? this.onConnectionLost_(e)
                : t === this.secondaryConn_
                ? (this.log_('Secondary connection lost.'),
                  this.onSecondaryConnectionLost_())
                : this.log_('closing an old connection');
        };
    }
    connReceiver_(t) {
        return (e) => {
            2 !== this.state_ &&
                (t === this.rx_
                    ? this.onPrimaryMessageReceived_(e)
                    : t === this.secondaryConn_
                    ? this.onSecondaryMessageReceived_(e)
                    : this.log_('message on old connection'));
        };
    }
    sendRequest(e) {
        this.sendData_({ t: 'd', d: e });
    }
    tryCleanupConnection() {
        this.tx_ === this.secondaryConn_ &&
            this.rx_ === this.secondaryConn_ &&
            (this.log_(
                'cleaning up and promoting a connection: ' +
                    this.secondaryConn_.connId
            ),
            (this.conn_ = this.secondaryConn_),
            (this.secondaryConn_ = null));
    }
    onSecondaryControl_(e) {
        MESSAGE_TYPE in e &&
            ((e = e[MESSAGE_TYPE]) === SWITCH_ACK
                ? this.upgradeIfSecondaryHealthy_()
                : e === CONTROL_RESET
                ? (this.log_('Got a reset on secondary, closing it'),
                  this.secondaryConn_.close(),
                  (this.tx_ !== this.secondaryConn_ &&
                      this.rx_ !== this.secondaryConn_) ||
                      this.close())
                : e === CONTROL_PONG &&
                  (this.log_('got pong on secondary.'),
                  this.secondaryResponsesRequired_--,
                  this.upgradeIfSecondaryHealthy_()));
    }
    onSecondaryMessageReceived_(e) {
        var t = requireKey('t', e),
            e = requireKey('d', e);
        if ('c' === t) this.onSecondaryControl_(e);
        else {
            if ('d' !== t) throw new Error('Unknown protocol layer: ' + t);
            this.pendingDataMessages.push(e);
        }
    }
    upgradeIfSecondaryHealthy_() {
        this.secondaryResponsesRequired_ <= 0
            ? (this.log_('Secondary connection is healthy.'),
              (this.isHealthy_ = !0),
              this.secondaryConn_.markConnectionHealthy(),
              this.proceedWithUpgrade_())
            : (this.log_('sending ping on secondary.'),
              this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } }));
    }
    proceedWithUpgrade_() {
        this.secondaryConn_.start(),
            this.log_('sending client ack on secondary'),
            this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } }),
            this.log_('Ending transmission on primary'),
            this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } }),
            (this.tx_ = this.secondaryConn_),
            this.tryCleanupConnection();
    }
    onPrimaryMessageReceived_(e) {
        var t = requireKey('t', e),
            e = requireKey('d', e);
        'c' === t ? this.onControl_(e) : 'd' === t && this.onDataMessage_(e);
    }
    onDataMessage_(e) {
        this.onPrimaryResponse_(), this.onMessage_(e);
    }
    onPrimaryResponse_() {
        this.isHealthy_ ||
            (this.primaryResponsesRequired_--,
            this.primaryResponsesRequired_ <= 0 &&
                (this.log_('Primary connection is healthy.'),
                (this.isHealthy_ = !0),
                this.conn_.markConnectionHealthy()));
    }
    onControl_(e) {
        var t = requireKey(MESSAGE_TYPE, e);
        if (MESSAGE_DATA in e) {
            e = e[MESSAGE_DATA];
            if (t === SERVER_HELLO) this.onHandshake_(e);
            else if (t === END_TRANSMISSION) {
                this.log_('recvd end transmission on primary'),
                    (this.rx_ = this.secondaryConn_);
                for (let e = 0; e < this.pendingDataMessages.length; ++e)
                    this.onDataMessage_(this.pendingDataMessages[e]);
                (this.pendingDataMessages = []), this.tryCleanupConnection();
            } else
                t === CONTROL_SHUTDOWN
                    ? this.onConnectionShutdown_(e)
                    : t === CONTROL_RESET
                    ? this.onReset_(e)
                    : t === CONTROL_ERROR
                    ? error('Server Error: ' + e)
                    : t === CONTROL_PONG
                    ? (this.log_('got pong on primary.'),
                      this.onPrimaryResponse_(),
                      this.sendPingOnPrimaryIfNecessary_())
                    : error('Unknown control packet command: ' + t);
        }
    }
    onHandshake_(e) {
        var t = e.ts,
            n = e.v,
            r = e.h;
        (this.sessionId = e.s),
            (this.repoInfo_.host = r),
            0 === this.state_ &&
                (this.conn_.start(),
                this.onConnectionEstablished_(this.conn_, t),
                PROTOCOL_VERSION !== n &&
                    warn('Protocol version mismatch detected'),
                this.tryStartUpgrade_());
    }
    tryStartUpgrade_() {
        var e = this.transportManager_.upgradeTransport();
        e && this.startUpgrade_(e);
    }
    startUpgrade_(e) {
        (this.secondaryConn_ = new e(
            this.nextTransportId_(),
            this.repoInfo_,
            this.applicationId_,
            this.appCheckToken_,
            this.authToken_,
            this.sessionId
        )),
            (this.secondaryResponsesRequired_ =
                e.responsesRequiredToBeHealthy || 0);
        var t = this.connReceiver_(this.secondaryConn_),
            e = this.disconnReceiver_(this.secondaryConn_);
        this.secondaryConn_.open(t, e),
            setTimeoutNonBlocking(() => {
                this.secondaryConn_ &&
                    (this.log_('Timed out trying to upgrade.'),
                    this.secondaryConn_.close());
            }, Math.floor(UPGRADE_TIMEOUT));
    }
    onReset_(e) {
        this.log_('Reset packet received.  New host: ' + e),
            (this.repoInfo_.host = e),
            1 === this.state_
                ? this.close()
                : (this.closeConnections_(), this.start_());
    }
    onConnectionEstablished_(e, t) {
        this.log_('Realtime connection established.'),
            (this.conn_ = e),
            (this.state_ = 1),
            this.onReady_ &&
                (this.onReady_(t, this.sessionId), (this.onReady_ = null)),
            0 === this.primaryResponsesRequired_
                ? (this.log_('Primary connection is healthy.'),
                  (this.isHealthy_ = !0))
                : setTimeoutNonBlocking(() => {
                      this.sendPingOnPrimaryIfNecessary_();
                  }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));
    }
    sendPingOnPrimaryIfNecessary_() {
        this.isHealthy_ ||
            1 !== this.state_ ||
            (this.log_('sending ping on primary.'),
            this.sendData_({ t: 'c', d: { t: PING, d: {} } }));
    }
    onSecondaryConnectionLost_() {
        var e = this.secondaryConn_;
        (this.secondaryConn_ = null),
            (this.tx_ !== e && this.rx_ !== e) || this.close();
    }
    onConnectionLost_(e) {
        (this.conn_ = null),
            e || 0 !== this.state_
                ? 1 === this.state_ && this.log_('Realtime connection lost.')
                : (this.log_('Realtime connection failed.'),
                  this.repoInfo_.isCacheableHost() &&
                      (PersistentStorage.remove('host:' + this.repoInfo_.host),
                      (this.repoInfo_.internalHost = this.repoInfo_.host))),
            this.close();
    }
    onConnectionShutdown_(e) {
        this.log_('Connection shutdown command received. Shutting down...'),
            this.onKill_ && (this.onKill_(e), (this.onKill_ = null)),
            (this.onDisconnect_ = null),
            this.close();
    }
    sendData_(e) {
        if (1 !== this.state_) throw 'Connection is not connected';
        this.tx_.send(e);
    }
    close() {
        2 !== this.state_ &&
            (this.log_('Closing realtime connection.'),
            (this.state_ = 2),
            this.closeConnections_(),
            this.onDisconnect_ &&
                (this.onDisconnect_(), (this.onDisconnect_ = null)));
    }
    closeConnections_() {
        this.log_('Shutting down all connections'),
            this.conn_ && (this.conn_.close(), (this.conn_ = null)),
            this.secondaryConn_ &&
                (this.secondaryConn_.close(), (this.secondaryConn_ = null)),
            this.healthyTimeout_ &&
                (clearTimeout(this.healthyTimeout_),
                (this.healthyTimeout_ = null));
    }
}
class ServerActions {
    put(e, t, n, r) {}
    merge(e, t, n, r) {}
    refreshAuthToken(e) {}
    refreshAppCheckToken(e) {}
    onDisconnectPut(e, t, n) {}
    onDisconnectMerge(e, t, n) {}
    onDisconnectCancel(e, t) {}
    reportStats(e) {}
}
class EventEmitter {
    constructor(e) {
        (this.allowedEvents_ = e),
            (this.listeners_ = {}),
            assert(
                Array.isArray(e) && 0 < e.length,
                'Requires a non-empty array'
            );
    }
    trigger(e, ...t) {
        if (Array.isArray(this.listeners_[e])) {
            const n = [...this.listeners_[e]];
            for (let e = 0; e < n.length; e++)
                n[e].callback.apply(n[e].context, t);
        }
    }
    on(e, t, n) {
        this.validateEventType_(e),
            (this.listeners_[e] = this.listeners_[e] || []),
            this.listeners_[e].push({ callback: t, context: n });
        e = this.getInitialEvent(e);
        e && t.apply(n, e);
    }
    off(e, t, n) {
        this.validateEventType_(e);
        const r = this.listeners_[e] || [];
        for (let e = 0; e < r.length; e++)
            if (r[e].callback === t && (!n || n === r[e].context))
                return void r.splice(e, 1);
    }
    validateEventType_(t) {
        assert(
            this.allowedEvents_.find((e) => e === t),
            'Unknown event: ' + t
        );
    }
}
class OnlineMonitor extends EventEmitter {
    constructor() {
        super(['online']),
            (this.online_ = !0),
            'undefined' == typeof window ||
                void 0 === window.addEventListener ||
                isMobileCordova() ||
                (window.addEventListener(
                    'online',
                    () => {
                        this.online_ ||
                            ((this.online_ = !0), this.trigger('online', !0));
                    },
                    !1
                ),
                window.addEventListener(
                    'offline',
                    () => {
                        this.online_ &&
                            ((this.online_ = !1), this.trigger('online', !1));
                    },
                    !1
                ));
    }
    static getInstance() {
        return new OnlineMonitor();
    }
    getInitialEvent(e) {
        return (
            assert('online' === e, 'Unknown event type: ' + e), [this.online_]
        );
    }
    currentlyOnline() {
        return this.online_;
    }
}
const MAX_PATH_DEPTH = 32,
    MAX_PATH_LENGTH_BYTES = 768;
class Path {
    constructor(e, t) {
        if (void 0 === t) {
            this.pieces_ = e.split('/');
            let t = 0;
            for (let e = 0; e < this.pieces_.length; e++)
                0 < this.pieces_[e].length &&
                    ((this.pieces_[t] = this.pieces_[e]), t++);
            (this.pieces_.length = t), (this.pieceNum_ = 0);
        } else (this.pieces_ = e), (this.pieceNum_ = t);
    }
    toString() {
        let t = '';
        for (let e = this.pieceNum_; e < this.pieces_.length; e++)
            '' !== this.pieces_[e] && (t += '/' + this.pieces_[e]);
        return t || '/';
    }
}
function newEmptyPath() {
    return new Path('');
}
function pathGetFront(e) {
    return e.pieceNum_ >= e.pieces_.length ? null : e.pieces_[e.pieceNum_];
}
function pathGetLength(e) {
    return e.pieces_.length - e.pieceNum_;
}
function pathPopFront(e) {
    let t = e.pieceNum_;
    return t < e.pieces_.length && t++, new Path(e.pieces_, t);
}
function pathGetBack(e) {
    return e.pieceNum_ < e.pieces_.length
        ? e.pieces_[e.pieces_.length - 1]
        : null;
}
function pathToUrlEncodedString(t) {
    let n = '';
    for (let e = t.pieceNum_; e < t.pieces_.length; e++)
        '' !== t.pieces_[e] &&
            (n += '/' + encodeURIComponent(String(t.pieces_[e])));
    return n || '/';
}
function pathSlice(e, t = 0) {
    return e.pieces_.slice(e.pieceNum_ + t);
}
function pathParent(t) {
    if (t.pieceNum_ >= t.pieces_.length) return null;
    const n = [];
    for (let e = t.pieceNum_; e < t.pieces_.length - 1; e++)
        n.push(t.pieces_[e]);
    return new Path(n, 0);
}
function pathChild(t, n) {
    const r = [];
    for (let e = t.pieceNum_; e < t.pieces_.length; e++) r.push(t.pieces_[e]);
    if (n instanceof Path)
        for (let e = n.pieceNum_; e < n.pieces_.length; e++)
            r.push(n.pieces_[e]);
    else {
        var i = n.split('/');
        for (let e = 0; e < i.length; e++) 0 < i[e].length && r.push(i[e]);
    }
    return new Path(r, 0);
}
function pathIsEmpty(e) {
    return e.pieceNum_ >= e.pieces_.length;
}
function newRelativePath(e, t) {
    var n = pathGetFront(e),
        r = pathGetFront(t);
    if (null === n) return t;
    if (n === r) return newRelativePath(pathPopFront(e), pathPopFront(t));
    throw new Error(
        'INTERNAL ERROR: innerPath (' +
            t +
            ') is not within outerPath (' +
            e +
            ')'
    );
}
function pathCompare(e, t) {
    var n = pathSlice(e, 0),
        r = pathSlice(t, 0);
    for (let e = 0; e < n.length && e < r.length; e++) {
        var i = nameCompare(n[e], r[e]);
        if (0 !== i) return i;
    }
    return n.length === r.length ? 0 : n.length < r.length ? -1 : 1;
}
function pathEquals(n, r) {
    if (pathGetLength(n) !== pathGetLength(r)) return !1;
    for (let e = n.pieceNum_, t = r.pieceNum_; e <= n.pieces_.length; e++, t++)
        if (n.pieces_[e] !== r.pieces_[t]) return !1;
    return !0;
}
function pathContains(e, t) {
    let n = e.pieceNum_,
        r = t.pieceNum_;
    if (pathGetLength(e) > pathGetLength(t)) return !1;
    for (; n < e.pieces_.length; ) {
        if (e.pieces_[n] !== t.pieces_[r]) return !1;
        ++n, ++r;
    }
    return !0;
}
class ValidationPath {
    constructor(e, t) {
        (this.errorPrefix_ = t),
            (this.parts_ = pathSlice(e, 0)),
            (this.byteLength_ = Math.max(1, this.parts_.length));
        for (let e = 0; e < this.parts_.length; e++)
            this.byteLength_ += stringLength(this.parts_[e]);
        validationPathCheckValid(this);
    }
}
function validationPathPush(e, t) {
    0 < e.parts_.length && (e.byteLength_ += 1),
        e.parts_.push(t),
        (e.byteLength_ += stringLength(t)),
        validationPathCheckValid(e);
}
function validationPathPop(e) {
    var t = e.parts_.pop();
    (e.byteLength_ -= stringLength(t)), 0 < e.parts_.length && --e.byteLength_;
}
function validationPathCheckValid(e) {
    if (e.byteLength_ > MAX_PATH_LENGTH_BYTES)
        throw new Error(
            e.errorPrefix_ +
                'has a key path longer than ' +
                MAX_PATH_LENGTH_BYTES +
                ' bytes (' +
                e.byteLength_ +
                ').'
        );
    if (e.parts_.length > MAX_PATH_DEPTH)
        throw new Error(
            e.errorPrefix_ +
                'path specified exceeds the maximum depth that can be written (' +
                MAX_PATH_DEPTH +
                ') or object contains a cycle ' +
                validationPathToErrorString(e)
        );
}
function validationPathToErrorString(e) {
    return 0 === e.parts_.length
        ? ''
        : "in property '" + e.parts_.join('.') + "'";
}
class VisibilityMonitor extends EventEmitter {
    constructor() {
        super(['visible']);
        let t, e;
        'undefined' != typeof document &&
            void 0 !== document.addEventListener &&
            (void 0 !== document.hidden
                ? ((e = 'visibilitychange'), (t = 'hidden'))
                : void 0 !== document.mozHidden
                ? ((e = 'mozvisibilitychange'), (t = 'mozHidden'))
                : void 0 !== document.msHidden
                ? ((e = 'msvisibilitychange'), (t = 'msHidden'))
                : void 0 !== document.webkitHidden &&
                  ((e = 'webkitvisibilitychange'), (t = 'webkitHidden'))),
            (this.visible_ = !0),
            e &&
                document.addEventListener(
                    e,
                    () => {
                        var e = !document[t];
                        e !== this.visible_ &&
                            ((this.visible_ = e), this.trigger('visible', e));
                    },
                    !1
                );
    }
    static getInstance() {
        return new VisibilityMonitor();
    }
    getInitialEvent(e) {
        return (
            assert('visible' === e, 'Unknown event type: ' + e), [this.visible_]
        );
    }
}
const RECONNECT_MIN_DELAY = 1e3,
    RECONNECT_MAX_DELAY_DEFAULT = 3e5,
    GET_CONNECT_TIMEOUT = 3e3,
    RECONNECT_MAX_DELAY_FOR_ADMINS = 3e4,
    RECONNECT_DELAY_MULTIPLIER = 1.3,
    RECONNECT_DELAY_RESET_TIMEOUT = 3e4,
    SERVER_KILL_INTERRUPT_REASON = 'server_kill',
    INVALID_TOKEN_THRESHOLD = 3;
class PersistentConnection extends ServerActions {
    constructor(e, t, n, r, i, o, s, a) {
        if (
            (super(),
            (this.repoInfo_ = e),
            (this.applicationId_ = t),
            (this.onDataUpdate_ = n),
            (this.onConnectStatus_ = r),
            (this.onServerInfoUpdate_ = i),
            (this.authTokenProvider_ = o),
            (this.appCheckTokenProvider_ = s),
            (this.authOverride_ = a),
            (this.id = PersistentConnection.nextPersistentConnectionId_++),
            (this.log_ = logWrapper('p:' + this.id + ':')),
            (this.interruptReasons_ = {}),
            (this.listens = new Map()),
            (this.outstandingPuts_ = []),
            (this.outstandingGets_ = []),
            (this.outstandingPutCount_ = 0),
            (this.outstandingGetCount_ = 0),
            (this.onDisconnectRequestQueue_ = []),
            (this.connected_ = !1),
            (this.reconnectDelay_ = RECONNECT_MIN_DELAY),
            (this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT),
            (this.securityDebugCallback_ = null),
            (this.lastSessionId = null),
            (this.establishConnectionTimer_ = null),
            (this.visible_ = !1),
            (this.requestCBHash_ = {}),
            (this.requestNumber_ = 0),
            (this.realtime_ = null),
            (this.authToken_ = null),
            (this.appCheckToken_ = null),
            (this.forceTokenRefresh_ = !1),
            (this.invalidAuthTokenCount_ = 0),
            (this.invalidAppCheckTokenCount_ = 0),
            (this.firstConnection_ = !0),
            (this.lastConnectionAttemptTime_ = null),
            (this.lastConnectionEstablishedTime_ = null),
            a && !isNodeSdk())
        )
            throw new Error(
                'Auth override specified in options, but not supported on non Node.js platforms'
            );
        VisibilityMonitor.getInstance().on('visible', this.onVisible_, this),
            -1 === e.host.indexOf('fblocal') &&
                OnlineMonitor.getInstance().on('online', this.onOnline_, this);
    }
    sendRequest(e, t, n) {
        var r = ++this.requestNumber_,
            t = { r: r, a: e, b: t };
        this.log_(stringify(t)),
            assert(
                this.connected_,
                "sendRequest call when we're not connected not allowed."
            ),
            this.realtime_.sendRequest(t),
            n && (this.requestCBHash_[r] = n);
    }
    get(e) {
        this.initConnection_();
        const n = new Deferred(),
            r = { p: e._path.toString(), q: e._queryObject },
            t = {
                action: 'g',
                request: r,
                onComplete: (e) => {
                    var t = e.d;
                    'ok' === e.s
                        ? (this.onDataUpdate_(r.p, t, !1, null), n.resolve(t))
                        : n.reject(t);
                },
            };
        this.outstandingGets_.push(t), this.outstandingGetCount_++;
        const i = this.outstandingGets_.length - 1;
        return (
            this.connected_ ||
                setTimeout(() => {
                    var e = this.outstandingGets_[i];
                    void 0 !== e &&
                        t === e &&
                        (delete this.outstandingGets_[i],
                        this.outstandingGetCount_--,
                        0 === this.outstandingGetCount_ &&
                            (this.outstandingGets_ = []),
                        this.log_('get ' + i + ' timed out on connection'),
                        n.reject(new Error('Client is offline.')));
                }, GET_CONNECT_TIMEOUT),
            this.connected_ && this.sendGet_(i),
            n.promise
        );
    }
    listen(e, t, n, r) {
        this.initConnection_();
        var i = e._queryIdentifier,
            o = e._path.toString();
        this.log_('Listen called for ' + o + ' ' + i),
            this.listens.has(o) || this.listens.set(o, new Map()),
            assert(
                e._queryParams.isDefault() || !e._queryParams.loadsAllData(),
                'listen() called for non-default but complete query'
            ),
            assert(
                !this.listens.get(o).has(i),
                'listen() called twice for same path/queryId.'
            );
        n = { onComplete: r, hashFn: t, query: e, tag: n };
        this.listens.get(o).set(i, n), this.connected_ && this.sendListen_(n);
    }
    sendGet_(t) {
        const n = this.outstandingGets_[t];
        this.sendRequest('g', n.request, (e) => {
            delete this.outstandingGets_[t],
                this.outstandingGetCount_--,
                0 === this.outstandingGetCount_ && (this.outstandingGets_ = []),
                n.onComplete && n.onComplete(e);
        });
    }
    sendListen_(r) {
        const i = r.query,
            o = i._path.toString(),
            s = i._queryIdentifier;
        this.log_('Listen on ' + o + ' for ' + s);
        const e = { p: o };
        r.tag && ((e.q = i._queryObject), (e.t = r.tag)),
            (e.h = r.hashFn()),
            this.sendRequest('q', e, (e) => {
                var t = e.d,
                    n = e.s;
                PersistentConnection.warnOnListenWarnings_(t, i),
                    (this.listens.get(o) && this.listens.get(o).get(s)) === r &&
                        (this.log_('listen response', e),
                        'ok' !== n && this.removeListen_(o, s),
                        r.onComplete && r.onComplete(n, t));
            });
    }
    static warnOnListenWarnings_(e, t) {
        if (e && 'object' == typeof e && contains(e, 'w')) {
            const n = safeGet(e, 'w');
            Array.isArray(n) &&
                ~n.indexOf('no_index') &&
                ((e =
                    '".indexOn": "' +
                    t._queryParams.getIndex().toString() +
                    '"'),
                (t = t._path.toString()),
                warn(
                    'Using an unspecified index. Your data will be downloaded and ' +
                        `filtered on the client. Consider adding ${e} at ` +
                        `${t} to your security rules for better performance.`
                ));
        }
    }
    refreshAuthToken(e) {
        (this.authToken_ = e),
            this.log_('Auth token refreshed'),
            this.authToken_
                ? this.tryAuth()
                : this.connected_ && this.sendRequest('unauth', {}, () => {}),
            this.reduceReconnectDelayIfAdminCredential_(e);
    }
    reduceReconnectDelayIfAdminCredential_(e) {
        ((e && 40 === e.length) || isAdmin(e)) &&
            (this.log_(
                'Admin auth credential detected.  Reducing max reconnect time.'
            ),
            (this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS));
    }
    refreshAppCheckToken(e) {
        (this.appCheckToken_ = e),
            this.log_('App check token refreshed'),
            this.appCheckToken_
                ? this.tryAppCheck()
                : this.connected_ && this.sendRequest('unappeck', {}, () => {});
    }
    tryAuth() {
        if (this.connected_ && this.authToken_) {
            const n = this.authToken_;
            var e = isValidFormat(n) ? 'auth' : 'gauth';
            const t = { cred: n };
            null === this.authOverride_
                ? (t.noauth = !0)
                : 'object' == typeof this.authOverride_ &&
                  (t.authvar = this.authOverride_),
                this.sendRequest(e, t, (e) => {
                    var t = e.s,
                        e = e.d || 'error';
                    this.authToken_ === n &&
                        ('ok' === t
                            ? (this.invalidAuthTokenCount_ = 0)
                            : this.onAuthRevoked_(t, e));
                });
        }
    }
    tryAppCheck() {
        this.connected_ &&
            this.appCheckToken_ &&
            this.sendRequest(
                'appcheck',
                { token: this.appCheckToken_ },
                (e) => {
                    var t = e.s,
                        e = e.d || 'error';
                    'ok' === t
                        ? (this.invalidAppCheckTokenCount_ = 0)
                        : this.onAppCheckRevoked_(t, e);
                }
            );
    }
    unlisten(e, t) {
        var n = e._path.toString(),
            r = e._queryIdentifier;
        this.log_('Unlisten called for ' + n + ' ' + r),
            assert(
                e._queryParams.isDefault() || !e._queryParams.loadsAllData(),
                'unlisten() called for non-default but complete query'
            ),
            this.removeListen_(n, r) &&
                this.connected_ &&
                this.sendUnlisten_(n, r, e._queryObject, t);
    }
    sendUnlisten_(e, t, n, r) {
        this.log_('Unlisten on ' + e + ' for ' + t);
        const i = { p: e };
        r && ((i.q = n), (i.t = r)), this.sendRequest('n', i);
    }
    onDisconnectPut(e, t, n) {
        this.initConnection_(),
            this.connected_
                ? this.sendOnDisconnect_('o', e, t, n)
                : this.onDisconnectRequestQueue_.push({
                      pathString: e,
                      action: 'o',
                      data: t,
                      onComplete: n,
                  });
    }
    onDisconnectMerge(e, t, n) {
        this.initConnection_(),
            this.connected_
                ? this.sendOnDisconnect_('om', e, t, n)
                : this.onDisconnectRequestQueue_.push({
                      pathString: e,
                      action: 'om',
                      data: t,
                      onComplete: n,
                  });
    }
    onDisconnectCancel(e, t) {
        this.initConnection_(),
            this.connected_
                ? this.sendOnDisconnect_('oc', e, null, t)
                : this.onDisconnectRequestQueue_.push({
                      pathString: e,
                      action: 'oc',
                      data: null,
                      onComplete: t,
                  });
    }
    sendOnDisconnect_(e, t, n, r) {
        n = { p: t, d: n };
        this.log_('onDisconnect ' + e, n),
            this.sendRequest(e, n, (e) => {
                r &&
                    setTimeout(() => {
                        r(e.s, e.d);
                    }, Math.floor(0));
            });
    }
    put(e, t, n, r) {
        this.putInternal('p', e, t, n, r);
    }
    merge(e, t, n, r) {
        this.putInternal('m', e, t, n, r);
    }
    putInternal(e, t, n, r, i) {
        this.initConnection_();
        const o = { p: t, d: n };
        void 0 !== i && (o.h = i),
            this.outstandingPuts_.push({
                action: e,
                request: o,
                onComplete: r,
            }),
            this.outstandingPutCount_++;
        r = this.outstandingPuts_.length - 1;
        this.connected_ ? this.sendPut_(r) : this.log_('Buffering put: ' + t);
    }
    sendPut_(t) {
        const n = this.outstandingPuts_[t].action;
        var e = this.outstandingPuts_[t].request;
        const r = this.outstandingPuts_[t].onComplete;
        (this.outstandingPuts_[t].queued = this.connected_),
            this.sendRequest(n, e, (e) => {
                this.log_(n + ' response', e),
                    delete this.outstandingPuts_[t],
                    this.outstandingPutCount_--,
                    0 === this.outstandingPutCount_ &&
                        (this.outstandingPuts_ = []),
                    r && r(e.s, e.d);
            });
    }
    reportStats(e) {
        this.connected_ &&
            (this.log_('reportStats', (e = { c: e })),
            this.sendRequest('s', e, (e) => {
                'ok' !== e.s &&
                    ((e = e.d),
                    this.log_('reportStats', 'Error sending stats: ' + e));
            }));
    }
    onDataMessage_(e) {
        if ('r' in e) {
            this.log_('from server: ' + stringify(e));
            var t = e.r;
            const n = this.requestCBHash_[t];
            n && (delete this.requestCBHash_[t], n(e.b));
        } else {
            if ('error' in e)
                throw 'A server-side error has occurred: ' + e.error;
            'a' in e && this.onDataPush_(e.a, e.b);
        }
    }
    onDataPush_(e, t) {
        this.log_('handleServerMessage', e, t),
            'd' === e
                ? this.onDataUpdate_(t.p, t.d, !1, t.t)
                : 'm' === e
                ? this.onDataUpdate_(t.p, t.d, !0, t.t)
                : 'c' === e
                ? this.onListenRevoked_(t.p, t.q)
                : 'ac' === e
                ? this.onAuthRevoked_(t.s, t.d)
                : 'apc' === e
                ? this.onAppCheckRevoked_(t.s, t.d)
                : 'sd' === e
                ? this.onSecurityDebugPacket_(t)
                : error(
                      'Unrecognized action received from server: ' +
                          stringify(e) +
                          '\nAre you using the latest client?'
                  );
    }
    onReady_(e, t) {
        this.log_('connection ready'),
            (this.connected_ = !0),
            (this.lastConnectionEstablishedTime_ = new Date().getTime()),
            this.handleTimestamp_(e),
            (this.lastSessionId = t),
            this.firstConnection_ && this.sendConnectStats_(),
            this.restoreState_(),
            (this.firstConnection_ = !1),
            this.onConnectStatus_(!0);
    }
    scheduleConnect_(e) {
        assert(
            !this.realtime_,
            "Scheduling a connect when we're already connected/ing?"
        ),
            this.establishConnectionTimer_ &&
                clearTimeout(this.establishConnectionTimer_),
            (this.establishConnectionTimer_ = setTimeout(() => {
                (this.establishConnectionTimer_ = null),
                    this.establishConnection_();
            }, Math.floor(e)));
    }
    initConnection_() {
        !this.realtime_ && this.firstConnection_ && this.scheduleConnect_(0);
    }
    onVisible_(e) {
        e &&
            !this.visible_ &&
            this.reconnectDelay_ === this.maxReconnectDelay_ &&
            (this.log_('Window became visible.  Reducing delay.'),
            (this.reconnectDelay_ = RECONNECT_MIN_DELAY),
            this.realtime_ || this.scheduleConnect_(0)),
            (this.visible_ = e);
    }
    onOnline_(e) {
        e
            ? (this.log_('Browser went online.'),
              (this.reconnectDelay_ = RECONNECT_MIN_DELAY),
              this.realtime_ || this.scheduleConnect_(0))
            : (this.log_('Browser went offline.  Killing connection.'),
              this.realtime_ && this.realtime_.close());
    }
    onRealtimeDisconnect_() {
        var e;
        this.log_('data client disconnected'),
            (this.connected_ = !1),
            (this.realtime_ = null),
            this.cancelSentTransactions_(),
            (this.requestCBHash_ = {}),
            this.shouldReconnect_() &&
                (this.visible_
                    ? this.lastConnectionEstablishedTime_ &&
                      (new Date().getTime() -
                          this.lastConnectionEstablishedTime_ >
                          RECONNECT_DELAY_RESET_TIMEOUT &&
                          (this.reconnectDelay_ = RECONNECT_MIN_DELAY),
                      (this.lastConnectionEstablishedTime_ = null))
                    : (this.log_("Window isn't visible.  Delaying reconnect."),
                      (this.reconnectDelay_ = this.maxReconnectDelay_),
                      (this.lastConnectionAttemptTime_ = new Date().getTime())),
                (e = new Date().getTime() - this.lastConnectionAttemptTime_),
                (e = Math.max(0, this.reconnectDelay_ - e)),
                (e = Math.random() * e),
                this.log_('Trying to reconnect in ' + e + 'ms'),
                this.scheduleConnect_(e),
                (this.reconnectDelay_ = Math.min(
                    this.maxReconnectDelay_,
                    this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER
                ))),
            this.onConnectStatus_(!1);
    }
    async establishConnection_() {
        if (this.shouldReconnect_()) {
            this.log_('Making a connection attempt'),
                (this.lastConnectionAttemptTime_ = new Date().getTime()),
                (this.lastConnectionEstablishedTime_ = null);
            var e = this.onDataMessage_.bind(this),
                r = this.onReady_.bind(this);
            const c = this.onRealtimeDisconnect_.bind(this);
            var i = this.id + ':' + PersistentConnection.nextConnectionId_++,
                o = this.lastSessionId;
            let t = !1,
                n = null;
            function s() {
                n ? n.close() : ((t = !0), c());
            }
            this.realtime_ = {
                close: s,
                sendRequest: function (e) {
                    assert(
                        n,
                        "sendRequest call when we're not connected not allowed."
                    ),
                        n.sendRequest(e);
                },
            };
            var a = this.forceTokenRefresh_;
            this.forceTokenRefresh_ = !1;
            try {
                var [l, h] = await Promise.all([
                    this.authTokenProvider_.getToken(a),
                    this.appCheckTokenProvider_.getToken(a),
                ]);
                t
                    ? log('getToken() completed but was canceled')
                    : (log('getToken() completed. Creating connection.'),
                      (this.authToken_ = l && l.accessToken),
                      (this.appCheckToken_ = h && h.token),
                      (n = new Connection(
                          i,
                          this.repoInfo_,
                          this.applicationId_,
                          this.appCheckToken_,
                          this.authToken_,
                          e,
                          r,
                          c,
                          (e) => {
                              warn(e + ' (' + this.repoInfo_.toString() + ')'),
                                  this.interrupt(SERVER_KILL_INTERRUPT_REASON);
                          },
                          o
                      )));
            } catch (e) {
                this.log_('Failed to get token: ' + e),
                    t || (this.repoInfo_.nodeAdmin && warn(e), s());
            }
        }
    }
    interrupt(e) {
        log('Interrupting connection for reason: ' + e),
            (this.interruptReasons_[e] = !0),
            this.realtime_
                ? this.realtime_.close()
                : (this.establishConnectionTimer_ &&
                      (clearTimeout(this.establishConnectionTimer_),
                      (this.establishConnectionTimer_ = null)),
                  this.connected_ && this.onRealtimeDisconnect_());
    }
    resume(e) {
        log('Resuming connection for reason: ' + e),
            delete this.interruptReasons_[e],
            isEmpty(this.interruptReasons_) &&
                ((this.reconnectDelay_ = RECONNECT_MIN_DELAY),
                this.realtime_ || this.scheduleConnect_(0));
    }
    handleTimestamp_(e) {
        e -= new Date().getTime();
        this.onServerInfoUpdate_({ serverTimeOffset: e });
    }
    cancelSentTransactions_() {
        for (let e = 0; e < this.outstandingPuts_.length; e++) {
            const t = this.outstandingPuts_[e];
            t &&
                'h' in t.request &&
                t.queued &&
                (t.onComplete && t.onComplete('disconnect'),
                delete this.outstandingPuts_[e],
                this.outstandingPutCount_--);
        }
        0 === this.outstandingPutCount_ && (this.outstandingPuts_ = []);
    }
    onListenRevoked_(e, t) {
        let n;
        n = t ? t.map((e) => ObjectToUniqueKey(e)).join('$') : 'default';
        const r = this.removeListen_(e, n);
        r && r.onComplete && r.onComplete('permission_denied');
    }
    removeListen_(e, t) {
        e = new Path(e).toString();
        let n;
        if (this.listens.has(e)) {
            const r = this.listens.get(e);
            (n = r.get(t)), r.delete(t), 0 === r.size && this.listens.delete(e);
        } else n = void 0;
        return n;
    }
    onAuthRevoked_(e, t) {
        log('Auth token revoked: ' + e + '/' + t),
            (this.authToken_ = null),
            (this.forceTokenRefresh_ = !0),
            this.realtime_.close(),
            ('invalid_token' !== e && 'permission_denied' !== e) ||
                (this.invalidAuthTokenCount_++,
                this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD &&
                    ((this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS),
                    this.authTokenProvider_.notifyForInvalidToken()));
    }
    onAppCheckRevoked_(e, t) {
        log('App check token revoked: ' + e + '/' + t),
            (this.appCheckToken_ = null),
            (this.forceTokenRefresh_ = !0),
            ('invalid_token' !== e && 'permission_denied' !== e) ||
                (this.invalidAppCheckTokenCount_++,
                this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD &&
                    this.appCheckTokenProvider_.notifyForInvalidToken());
    }
    onSecurityDebugPacket_(e) {
        this.securityDebugCallback_
            ? this.securityDebugCallback_(e)
            : 'msg' in e &&
              console.log('FIREBASE: ' + e.msg.replace('\n', '\nFIREBASE: '));
    }
    restoreState_() {
        this.tryAuth(), this.tryAppCheck();
        for (const t of this.listens.values())
            for (const n of t.values()) this.sendListen_(n);
        for (let e = 0; e < this.outstandingPuts_.length; e++)
            this.outstandingPuts_[e] && this.sendPut_(e);
        for (; this.onDisconnectRequestQueue_.length; ) {
            var e = this.onDisconnectRequestQueue_.shift();
            this.sendOnDisconnect_(
                e.action,
                e.pathString,
                e.data,
                e.onComplete
            );
        }
        for (let e = 0; e < this.outstandingGets_.length; e++)
            this.outstandingGets_[e] && this.sendGet_(e);
    }
    sendConnectStats_() {
        const e = {};
        (e['sdk.js.' + SDK_VERSION.replace(/\./g, '-')] = 1),
            isMobileCordova()
                ? (e['framework.cordova'] = 1)
                : isReactNative() && (e['framework.reactnative'] = 1),
            this.reportStats(e);
    }
    shouldReconnect_() {
        var e = OnlineMonitor.getInstance().currentlyOnline();
        return isEmpty(this.interruptReasons_) && e;
    }
}
(PersistentConnection.nextPersistentConnectionId_ = 0),
    (PersistentConnection.nextConnectionId_ = 0);
class NamedNode {
    constructor(e, t) {
        (this.name = e), (this.node = t);
    }
    static Wrap(e, t) {
        return new NamedNode(e, t);
    }
}
class Index {
    getCompare() {
        return this.compare.bind(this);
    }
    indexedValueChanged(e, t) {
        (e = new NamedNode(MIN_NAME, e)), (t = new NamedNode(MIN_NAME, t));
        return 0 !== this.compare(e, t);
    }
    minPost() {
        return NamedNode.MIN;
    }
}
let __EMPTY_NODE;
class KeyIndex extends Index {
    static get __EMPTY_NODE() {
        return __EMPTY_NODE;
    }
    static set __EMPTY_NODE(e) {
        __EMPTY_NODE = e;
    }
    compare(e, t) {
        return nameCompare(e.name, t.name);
    }
    isDefinedOn(e) {
        throw assertionError('KeyIndex.isDefinedOn not expected to be called.');
    }
    indexedValueChanged(e, t) {
        return !1;
    }
    minPost() {
        return NamedNode.MIN;
    }
    maxPost() {
        return new NamedNode(MAX_NAME, __EMPTY_NODE);
    }
    makePost(e, t) {
        return (
            assert(
                'string' == typeof e,
                'KeyIndex indexValue must always be a string.'
            ),
            new NamedNode(e, __EMPTY_NODE)
        );
    }
    toString() {
        return '.key';
    }
}
const KEY_INDEX = new KeyIndex();
class SortedMapIterator {
    constructor(e, t, n, r, i = null) {
        (this.isReverse_ = r),
            (this.resultGenerator_ = i),
            (this.nodeStack_ = []);
        let o = 1;
        for (; !e.isEmpty(); )
            if (((o = t ? n(e.key, t) : 1), r && (o *= -1), o < 0))
                e = this.isReverse_ ? e.left : e.right;
            else {
                if (0 === o) {
                    this.nodeStack_.push(e);
                    break;
                }
                this.nodeStack_.push(e),
                    (e = this.isReverse_ ? e.right : e.left);
            }
    }
    getNext() {
        if (0 === this.nodeStack_.length) return null;
        let e = this.nodeStack_.pop(),
            t;
        if (
            ((t = this.resultGenerator_
                ? this.resultGenerator_(e.key, e.value)
                : { key: e.key, value: e.value }),
            this.isReverse_)
        )
            for (e = e.left; !e.isEmpty(); )
                this.nodeStack_.push(e), (e = e.right);
        else
            for (e = e.right; !e.isEmpty(); )
                this.nodeStack_.push(e), (e = e.left);
        return t;
    }
    hasNext() {
        return 0 < this.nodeStack_.length;
    }
    peek() {
        if (0 === this.nodeStack_.length) return null;
        var e = this.nodeStack_[this.nodeStack_.length - 1];
        return this.resultGenerator_
            ? this.resultGenerator_(e.key, e.value)
            : { key: e.key, value: e.value };
    }
}
class LLRBNode {
    constructor(e, t, n, r, i) {
        (this.key = e),
            (this.value = t),
            (this.color = null != n ? n : LLRBNode.RED),
            (this.left = null != r ? r : SortedMap.EMPTY_NODE),
            (this.right = null != i ? i : SortedMap.EMPTY_NODE);
    }
    copy(e, t, n, r, i) {
        return new LLRBNode(
            null != e ? e : this.key,
            null != t ? t : this.value,
            null != n ? n : this.color,
            null != r ? r : this.left,
            null != i ? i : this.right
        );
    }
    count() {
        return this.left.count() + 1 + this.right.count();
    }
    isEmpty() {
        return !1;
    }
    inorderTraversal(e) {
        return (
            this.left.inorderTraversal(e) ||
            !!e(this.key, this.value) ||
            this.right.inorderTraversal(e)
        );
    }
    reverseTraversal(e) {
        return (
            this.right.reverseTraversal(e) ||
            e(this.key, this.value) ||
            this.left.reverseTraversal(e)
        );
    }
    min_() {
        return this.left.isEmpty() ? this : this.left.min_();
    }
    minKey() {
        return this.min_().key;
    }
    maxKey() {
        return this.right.isEmpty() ? this.key : this.right.maxKey();
    }
    insert(e, t, n) {
        let r = this;
        var i = n(e, r.key);
        return (
            (r =
                i < 0
                    ? r.copy(null, null, null, r.left.insert(e, t, n), null)
                    : 0 === i
                    ? r.copy(null, t, null, null, null)
                    : r.copy(null, null, null, null, r.right.insert(e, t, n))),
            r.fixUp_()
        );
    }
    removeMin_() {
        if (this.left.isEmpty()) return SortedMap.EMPTY_NODE;
        let e = this;
        return (
            e.left.isRed_() || e.left.left.isRed_() || (e = e.moveRedLeft_()),
            (e = e.copy(null, null, null, e.left.removeMin_(), null)),
            e.fixUp_()
        );
    }
    remove(e, t) {
        let n, r;
        if (((n = this), t(e, n.key) < 0))
            n.left.isEmpty() ||
                n.left.isRed_() ||
                n.left.left.isRed_() ||
                (n = n.moveRedLeft_()),
                (n = n.copy(null, null, null, n.left.remove(e, t), null));
        else {
            if (
                (n.left.isRed_() && (n = n.rotateRight_()),
                n.right.isEmpty() ||
                    n.right.isRed_() ||
                    n.right.left.isRed_() ||
                    (n = n.moveRedRight_()),
                0 === t(e, n.key))
            ) {
                if (n.right.isEmpty()) return SortedMap.EMPTY_NODE;
                (r = n.right.min_()),
                    (n = n.copy(
                        r.key,
                        r.value,
                        null,
                        null,
                        n.right.removeMin_()
                    ));
            }
            n = n.copy(null, null, null, null, n.right.remove(e, t));
        }
        return n.fixUp_();
    }
    isRed_() {
        return this.color;
    }
    fixUp_() {
        let e = this;
        return (
            e.right.isRed_() && !e.left.isRed_() && (e = e.rotateLeft_()),
            e.left.isRed_() && e.left.left.isRed_() && (e = e.rotateRight_()),
            e.left.isRed_() && e.right.isRed_() && (e = e.colorFlip_()),
            e
        );
    }
    moveRedLeft_() {
        let e = this.colorFlip_();
        return (
            e.right.left.isRed_() &&
                ((e = e.copy(null, null, null, null, e.right.rotateRight_())),
                (e = e.rotateLeft_()),
                (e = e.colorFlip_())),
            e
        );
    }
    moveRedRight_() {
        let e = this.colorFlip_();
        return (
            e.left.left.isRed_() &&
                ((e = e.rotateRight_()), (e = e.colorFlip_())),
            e
        );
    }
    rotateLeft_() {
        var e = this.copy(null, null, LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, e, null);
    }
    rotateRight_() {
        var e = this.copy(null, null, LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, e);
    }
    colorFlip_() {
        var e = this.left.copy(null, null, !this.left.color, null, null),
            t = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, e, t);
    }
    checkMaxDepth_() {
        var e = this.check_();
        return Math.pow(2, e) <= this.count() + 1;
    }
    check_() {
        if (this.isRed_() && this.left.isRed_())
            throw new Error(
                'Red node has red child(' + this.key + ',' + this.value + ')'
            );
        if (this.right.isRed_())
            throw new Error(
                'Right child of (' + this.key + ',' + this.value + ') is red'
            );
        var e = this.left.check_();
        if (e !== this.right.check_()) throw new Error('Black depths differ');
        return e + (this.isRed_() ? 0 : 1);
    }
}
(LLRBNode.RED = !0), (LLRBNode.BLACK = !1);
class LLRBEmptyNode {
    copy(e, t, n, r, i) {
        return this;
    }
    insert(e, t, n) {
        return new LLRBNode(e, t, null);
    }
    remove(e, t) {
        return this;
    }
    count() {
        return 0;
    }
    isEmpty() {
        return !0;
    }
    inorderTraversal(e) {
        return !1;
    }
    reverseTraversal(e) {
        return !1;
    }
    minKey() {
        return null;
    }
    maxKey() {
        return null;
    }
    check_() {
        return 0;
    }
    isRed_() {
        return !1;
    }
}
class SortedMap {
    constructor(e, t = SortedMap.EMPTY_NODE) {
        (this.comparator_ = e), (this.root_ = t);
    }
    insert(e, t) {
        return new SortedMap(
            this.comparator_,
            this.root_
                .insert(e, t, this.comparator_)
                .copy(null, null, LLRBNode.BLACK, null, null)
        );
    }
    remove(e) {
        return new SortedMap(
            this.comparator_,
            this.root_
                .remove(e, this.comparator_)
                .copy(null, null, LLRBNode.BLACK, null, null)
        );
    }
    get(e) {
        var t;
        let n = this.root_;
        for (; !n.isEmpty(); ) {
            if (0 === (t = this.comparator_(e, n.key))) return n.value;
            t < 0 ? (n = n.left) : 0 < t && (n = n.right);
        }
        return null;
    }
    getPredecessorKey(e) {
        let t,
            n = this.root_,
            r = null;
        for (; !n.isEmpty(); ) {
            if (0 === (t = this.comparator_(e, n.key))) {
                if (n.left.isEmpty()) return r ? r.key : null;
                for (n = n.left; !n.right.isEmpty(); ) n = n.right;
                return n.key;
            }
            t < 0 ? (n = n.left) : 0 < t && ((r = n), (n = n.right));
        }
        throw new Error(
            'Attempted to find predecessor key for a nonexistent key.  What gives?'
        );
    }
    isEmpty() {
        return this.root_.isEmpty();
    }
    count() {
        return this.root_.count();
    }
    minKey() {
        return this.root_.minKey();
    }
    maxKey() {
        return this.root_.maxKey();
    }
    inorderTraversal(e) {
        return this.root_.inorderTraversal(e);
    }
    reverseTraversal(e) {
        return this.root_.reverseTraversal(e);
    }
    getIterator(e) {
        return new SortedMapIterator(this.root_, null, this.comparator_, !1, e);
    }
    getIteratorFrom(e, t) {
        return new SortedMapIterator(this.root_, e, this.comparator_, !1, t);
    }
    getReverseIteratorFrom(e, t) {
        return new SortedMapIterator(this.root_, e, this.comparator_, !0, t);
    }
    getReverseIterator(e) {
        return new SortedMapIterator(this.root_, null, this.comparator_, !0, e);
    }
}
function NAME_ONLY_COMPARATOR(e, t) {
    return nameCompare(e.name, t.name);
}
function NAME_COMPARATOR(e, t) {
    return nameCompare(e, t);
}
SortedMap.EMPTY_NODE = new LLRBEmptyNode();
let MAX_NODE$2;
function setMaxNode$1(e) {
    MAX_NODE$2 = e;
}
const priorityHashText = function (e) {
        return 'number' == typeof e
            ? 'number:' + doubleToIEEE754String(e)
            : 'string:' + e;
    },
    validatePriorityNode = function (e) {
        var t;
        e.isLeafNode()
            ? ((t = e.val()),
              assert(
                  'string' == typeof t ||
                      'number' == typeof t ||
                      ('object' == typeof t && contains(t, '.sv')),
                  'Priority must be a string or number.'
              ))
            : assert(
                  e === MAX_NODE$2 || e.isEmpty(),
                  'priority of unexpected type.'
              ),
            assert(
                e === MAX_NODE$2 || e.getPriority().isEmpty(),
                "Priority nodes can't have a priority of their own."
            );
    };
let __childrenNodeConstructor;
class LeafNode {
    constructor(e, t = LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
        (this.value_ = e),
            (this.priorityNode_ = t),
            (this.lazyHash_ = null),
            assert(
                void 0 !== this.value_ && null !== this.value_,
                "LeafNode shouldn't be created with null/undefined value."
            ),
            validatePriorityNode(this.priorityNode_);
    }
    static set __childrenNodeConstructor(e) {
        __childrenNodeConstructor = e;
    }
    static get __childrenNodeConstructor() {
        return __childrenNodeConstructor;
    }
    isLeafNode() {
        return !0;
    }
    getPriority() {
        return this.priorityNode_;
    }
    updatePriority(e) {
        return new LeafNode(this.value_, e);
    }
    getImmediateChild(e) {
        return '.priority' === e
            ? this.priorityNode_
            : LeafNode.__childrenNodeConstructor.EMPTY_NODE;
    }
    getChild(e) {
        return pathIsEmpty(e)
            ? this
            : '.priority' === pathGetFront(e)
            ? this.priorityNode_
            : LeafNode.__childrenNodeConstructor.EMPTY_NODE;
    }
    hasChild() {
        return !1;
    }
    getPredecessorChildName(e, t) {
        return null;
    }
    updateImmediateChild(e, t) {
        return '.priority' === e
            ? this.updatePriority(t)
            : t.isEmpty() && '.priority' !== e
            ? this
            : LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(
                  e,
                  t
              ).updatePriority(this.priorityNode_);
    }
    updateChild(e, t) {
        var n = pathGetFront(e);
        return null === n
            ? t
            : t.isEmpty() && '.priority' !== n
            ? this
            : (assert(
                  '.priority' !== n || 1 === pathGetLength(e),
                  '.priority must be the last token in a path'
              ),
              this.updateImmediateChild(
                  n,
                  LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(
                      pathPopFront(e),
                      t
                  )
              ));
    }
    isEmpty() {
        return !1;
    }
    numChildren() {
        return 0;
    }
    forEachChild(e, t) {
        return !1;
    }
    val(e) {
        return e && !this.getPriority().isEmpty()
            ? {
                  '.value': this.getValue(),
                  '.priority': this.getPriority().val(),
              }
            : this.getValue();
    }
    hash() {
        if (null === this.lazyHash_) {
            let e = '';
            this.priorityNode_.isEmpty() ||
                (e +=
                    'priority:' +
                    priorityHashText(this.priorityNode_.val()) +
                    ':');
            var t = typeof this.value_;
            (e += t + ':'),
                (e +=
                    'number' == t
                        ? doubleToIEEE754String(this.value_)
                        : this.value_),
                (this.lazyHash_ = sha1(e));
        }
        return this.lazyHash_;
    }
    getValue() {
        return this.value_;
    }
    compareTo(e) {
        return e === LeafNode.__childrenNodeConstructor.EMPTY_NODE
            ? 1
            : e instanceof LeafNode.__childrenNodeConstructor
            ? -1
            : (assert(e.isLeafNode(), 'Unknown node type'),
              this.compareToLeafNode_(e));
    }
    compareToLeafNode_(e) {
        var t = typeof e.value_,
            n = typeof this.value_,
            r = LeafNode.VALUE_TYPE_ORDER.indexOf(t),
            i = LeafNode.VALUE_TYPE_ORDER.indexOf(n);
        return (
            assert(0 <= r, 'Unknown leaf type: ' + t),
            assert(0 <= i, 'Unknown leaf type: ' + n),
            r === i
                ? 'object' == n
                    ? 0
                    : this.value_ < e.value_
                    ? -1
                    : this.value_ === e.value_
                    ? 0
                    : 1
                : i - r
        );
    }
    withIndex() {
        return this;
    }
    isIndexed() {
        return !0;
    }
    equals(e) {
        return (
            e === this ||
            (!!e.isLeafNode() &&
                this.value_ === e.value_ &&
                this.priorityNode_.equals(e.priorityNode_))
        );
    }
}
LeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];
let nodeFromJSON$1, MAX_NODE$1;
function setNodeFromJSON(e) {
    nodeFromJSON$1 = e;
}
function setMaxNode(e) {
    MAX_NODE$1 = e;
}
class PriorityIndex extends Index {
    compare(e, t) {
        const n = e.node.getPriority();
        var r = t.node.getPriority(),
            r = n.compareTo(r);
        return 0 === r ? nameCompare(e.name, t.name) : r;
    }
    isDefinedOn(e) {
        return !e.getPriority().isEmpty();
    }
    indexedValueChanged(e, t) {
        return !e.getPriority().equals(t.getPriority());
    }
    minPost() {
        return NamedNode.MIN;
    }
    maxPost() {
        return new NamedNode(
            MAX_NAME,
            new LeafNode('[PRIORITY-POST]', MAX_NODE$1)
        );
    }
    makePost(e, t) {
        e = nodeFromJSON$1(e);
        return new NamedNode(t, new LeafNode('[PRIORITY-POST]', e));
    }
    toString() {
        return '.priority';
    }
}
const PRIORITY_INDEX = new PriorityIndex(),
    LOG_2 = Math.log(2);
class Base12Num {
    constructor(e) {
        var t;
        (this.count = ((t = e + 1), parseInt(Math.log(t) / LOG_2, 10))),
            (this.current_ = this.count - 1);
        var n,
            r = ((n = this.count), parseInt(Array(n + 1).join('1'), 2));
        this.bits_ = (e + 1) & r;
    }
    nextBitIsOne() {
        var e = !(this.bits_ & (1 << this.current_));
        return this.current_--, e;
    }
}
const buildChildSet = function (l, e, h, t) {
    l.sort(e);
    const c = function (e, t) {
        var n = t - e;
        let r, i;
        if (0 == n) return null;
        if (1 == n)
            return (
                (r = l[e]),
                (i = h ? h(r) : r),
                new LLRBNode(i, r.node, LLRBNode.BLACK, null, null)
            );
        (n = parseInt(n / 2, 10) + e), (e = c(e, n)), (t = c(n + 1, t));
        return (
            (r = l[n]),
            (i = h ? h(r) : r),
            new LLRBNode(i, r.node, LLRBNode.BLACK, e, t)
        );
    };
    var n = (function (t) {
        let i = null,
            o = null,
            s = l.length;
        function n(e, t) {
            var n = s - e,
                r = s;
            (s -= e),
                (e = c(1 + n, r)),
                (r = l[n]),
                (n = h ? h(r) : r),
                (function (e) {
                    if (i) {
                        i.left = e;
                        i = e;
                    } else {
                        o = e;
                        i = e;
                    }
                })(new LLRBNode(n, r.node, t, null, e));
        }
        for (let e = 0; e < t.count; ++e) {
            var r = t.nextBitIsOne(),
                a = Math.pow(2, t.count - (e + 1));
            r
                ? n(a, LLRBNode.BLACK)
                : (n(a, LLRBNode.BLACK), n(a, LLRBNode.RED));
        }
        return o;
    })(new Base12Num(l.length));
    return new SortedMap(t || e, n);
};
let _defaultIndexMap;
const fallbackObject = {};
class IndexMap {
    constructor(e, t) {
        (this.indexes_ = e), (this.indexSet_ = t);
    }
    static get Default() {
        return (
            assert(
                fallbackObject && PRIORITY_INDEX,
                'ChildrenNode.ts has not been loaded'
            ),
            (_defaultIndexMap =
                _defaultIndexMap ||
                new IndexMap(
                    { '.priority': fallbackObject },
                    { '.priority': PRIORITY_INDEX }
                )),
            _defaultIndexMap
        );
    }
    get(e) {
        var t = safeGet(this.indexes_, e);
        if (!t) throw new Error('No index defined for ' + e);
        return t instanceof SortedMap ? t : null;
    }
    hasIndex(e) {
        return contains(this.indexSet_, e.toString());
    }
    addIndex(e, t) {
        assert(
            e !== KEY_INDEX,
            "KeyIndex always exists and isn't meant to be added to the IndexMap."
        );
        const n = [];
        let r = !1;
        const i = t.getIterator(NamedNode.Wrap);
        let o = i.getNext();
        for (; o; )
            (r = r || e.isDefinedOn(o.node)), n.push(o), (o = i.getNext());
        let s;
        s = r ? buildChildSet(n, e.getCompare()) : fallbackObject;
        t = e.toString();
        const a = Object.assign({}, this.indexSet_);
        a[t] = e;
        const l = Object.assign({}, this.indexes_);
        return (l[t] = s), new IndexMap(l, a);
    }
    addToIndexes(s, a) {
        var e = map(this.indexes_, (t, n) => {
            const r = safeGet(this.indexSet_, n);
            if (
                (assert(r, 'Missing index implementation for ' + n),
                t === fallbackObject)
            ) {
                if (r.isDefinedOn(s.node)) {
                    const i = [],
                        o = a.getIterator(NamedNode.Wrap);
                    let e = o.getNext();
                    for (; e; )
                        e.name !== s.name && i.push(e), (e = o.getNext());
                    return i.push(s), buildChildSet(i, r.getCompare());
                }
                return fallbackObject;
            }
            {
                n = a.get(s.name);
                let e = t;
                return (
                    n && (e = e.remove(new NamedNode(s.name, n))),
                    e.insert(s, s.node)
                );
            }
        });
        return new IndexMap(e, this.indexSet_);
    }
    removeFromIndexes(n, r) {
        var e = map(this.indexes_, (e) => {
            if (e === fallbackObject) return e;
            var t = r.get(n.name);
            return t ? e.remove(new NamedNode(n.name, t)) : e;
        });
        return new IndexMap(e, this.indexSet_);
    }
}
let EMPTY_NODE;
class ChildrenNode {
    constructor(e, t, n) {
        (this.children_ = e),
            (this.priorityNode_ = t),
            (this.indexMap_ = n),
            (this.lazyHash_ = null),
            this.priorityNode_ && validatePriorityNode(this.priorityNode_),
            this.children_.isEmpty() &&
                assert(
                    !this.priorityNode_ || this.priorityNode_.isEmpty(),
                    'An empty node cannot have a priority'
                );
    }
    static get EMPTY_NODE() {
        return (EMPTY_NODE =
            EMPTY_NODE ||
            new ChildrenNode(
                new SortedMap(NAME_COMPARATOR),
                null,
                IndexMap.Default
            ));
    }
    isLeafNode() {
        return !1;
    }
    getPriority() {
        return this.priorityNode_ || EMPTY_NODE;
    }
    updatePriority(e) {
        return this.children_.isEmpty()
            ? this
            : new ChildrenNode(this.children_, e, this.indexMap_);
    }
    getImmediateChild(e) {
        if ('.priority' === e) return this.getPriority();
        e = this.children_.get(e);
        return null === e ? EMPTY_NODE : e;
    }
    getChild(e) {
        var t = pathGetFront(e);
        return null === t
            ? this
            : this.getImmediateChild(t).getChild(pathPopFront(e));
    }
    hasChild(e) {
        return null !== this.children_.get(e);
    }
    updateImmediateChild(n, r) {
        if (
            (assert(r, 'We should always be passing snapshot nodes'),
            '.priority' === n)
        )
            return this.updatePriority(r);
        {
            var i = new NamedNode(n, r);
            let e, t;
            t = r.isEmpty()
                ? ((e = this.children_.remove(n)),
                  this.indexMap_.removeFromIndexes(i, this.children_))
                : ((e = this.children_.insert(n, r)),
                  this.indexMap_.addToIndexes(i, this.children_));
            i = e.isEmpty() ? EMPTY_NODE : this.priorityNode_;
            return new ChildrenNode(e, i, t);
        }
    }
    updateChild(e, t) {
        var n = pathGetFront(e);
        if (null === n) return t;
        assert(
            '.priority' !== pathGetFront(e) || 1 === pathGetLength(e),
            '.priority must be the last token in a path'
        );
        t = this.getImmediateChild(n).updateChild(pathPopFront(e), t);
        return this.updateImmediateChild(n, t);
    }
    isEmpty() {
        return this.children_.isEmpty();
    }
    numChildren() {
        return this.children_.count();
    }
    val(n) {
        if (this.isEmpty()) return null;
        const r = {};
        let i = 0,
            o = 0,
            s = !0;
        if (
            (this.forEachChild(PRIORITY_INDEX, (e, t) => {
                (r[e] = t.val(n)),
                    i++,
                    s && ChildrenNode.INTEGER_REGEXP_.test(e)
                        ? (o = Math.max(o, Number(e)))
                        : (s = !1);
            }),
            !n && s && o < 2 * i)
        ) {
            const e = [];
            for (const t in r) e[t] = r[t];
            return e;
        }
        return (
            n &&
                !this.getPriority().isEmpty() &&
                (r['.priority'] = this.getPriority().val()),
            r
        );
    }
    hash() {
        if (null === this.lazyHash_) {
            let n = '';
            this.getPriority().isEmpty() ||
                (n +=
                    'priority:' +
                    priorityHashText(this.getPriority().val()) +
                    ':'),
                this.forEachChild(PRIORITY_INDEX, (e, t) => {
                    t = t.hash();
                    '' !== t && (n += ':' + e + ':' + t);
                }),
                (this.lazyHash_ = '' === n ? '' : sha1(n));
        }
        return this.lazyHash_;
    }
    getPredecessorChildName(e, t, n) {
        const r = this.resolveIndex_(n);
        if (r) {
            t = r.getPredecessorKey(new NamedNode(e, t));
            return t ? t.name : null;
        }
        return this.children_.getPredecessorKey(e);
    }
    getFirstChildName(e) {
        const t = this.resolveIndex_(e);
        if (t) {
            e = t.minKey();
            return e && e.name;
        }
        return this.children_.minKey();
    }
    getFirstChild(e) {
        e = this.getFirstChildName(e);
        return e ? new NamedNode(e, this.children_.get(e)) : null;
    }
    getLastChildName(e) {
        const t = this.resolveIndex_(e);
        if (t) {
            e = t.maxKey();
            return e && e.name;
        }
        return this.children_.maxKey();
    }
    getLastChild(e) {
        e = this.getLastChildName(e);
        return e ? new NamedNode(e, this.children_.get(e)) : null;
    }
    forEachChild(e, t) {
        const n = this.resolveIndex_(e);
        return n
            ? n.inorderTraversal((e) => t(e.name, e.node))
            : this.children_.inorderTraversal(t);
    }
    getIterator(e) {
        return this.getIteratorFrom(e.minPost(), e);
    }
    getIteratorFrom(t, n) {
        const e = this.resolveIndex_(n);
        if (e) return e.getIteratorFrom(t, (e) => e);
        {
            const r = this.children_.getIteratorFrom(t.name, NamedNode.Wrap);
            let e = r.peek();
            for (; null != e && n.compare(e, t) < 0; )
                r.getNext(), (e = r.peek());
            return r;
        }
    }
    getReverseIterator(e) {
        return this.getReverseIteratorFrom(e.maxPost(), e);
    }
    getReverseIteratorFrom(t, n) {
        const e = this.resolveIndex_(n);
        if (e) return e.getReverseIteratorFrom(t, (e) => e);
        {
            const r = this.children_.getReverseIteratorFrom(
                t.name,
                NamedNode.Wrap
            );
            let e = r.peek();
            for (; null != e && 0 < n.compare(e, t); )
                r.getNext(), (e = r.peek());
            return r;
        }
    }
    compareTo(e) {
        return this.isEmpty()
            ? e.isEmpty()
                ? 0
                : -1
            : e.isLeafNode() || e.isEmpty()
            ? 1
            : e === MAX_NODE
            ? -1
            : 0;
    }
    withIndex(e) {
        if (e === KEY_INDEX || this.indexMap_.hasIndex(e)) return this;
        e = this.indexMap_.addIndex(e, this.children_);
        return new ChildrenNode(this.children_, this.priorityNode_, e);
    }
    isIndexed(e) {
        return e === KEY_INDEX || this.indexMap_.hasIndex(e);
    }
    equals(e) {
        if (e === this) return !0;
        if (e.isLeafNode()) return !1;
        {
            const n = e;
            if (this.getPriority().equals(n.getPriority())) {
                if (this.children_.count() !== n.children_.count()) return !1;
                {
                    const r = this.getIterator(PRIORITY_INDEX),
                        i = n.getIterator(PRIORITY_INDEX);
                    let e = r.getNext(),
                        t = i.getNext();
                    for (; e && t; ) {
                        if (e.name !== t.name || !e.node.equals(t.node))
                            return !1;
                        (e = r.getNext()), (t = i.getNext());
                    }
                    return null === e && null === t;
                }
            }
            return !1;
        }
    }
    resolveIndex_(e) {
        return e === KEY_INDEX ? null : this.indexMap_.get(e.toString());
    }
}
ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
class MaxNode extends ChildrenNode {
    constructor() {
        super(
            new SortedMap(NAME_COMPARATOR),
            ChildrenNode.EMPTY_NODE,
            IndexMap.Default
        );
    }
    compareTo(e) {
        return e === this ? 0 : 1;
    }
    equals(e) {
        return e === this;
    }
    getPriority() {
        return this;
    }
    getImmediateChild(e) {
        return ChildrenNode.EMPTY_NODE;
    }
    isEmpty() {
        return !1;
    }
}
const MAX_NODE = new MaxNode();
Object.defineProperties(NamedNode, {
    MIN: { value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE) },
    MAX: { value: new NamedNode(MAX_NAME, MAX_NODE) },
}),
    (KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE),
    (LeafNode.__childrenNodeConstructor = ChildrenNode),
    setMaxNode$1(MAX_NODE),
    setMaxNode(MAX_NODE);
const USE_HINZE = !0;
function nodeFromJSON(i, e = null) {
    if (null === i) return ChildrenNode.EMPTY_NODE;
    if (
        ('object' == typeof i && '.priority' in i && (e = i['.priority']),
        assert(
            null === e ||
                'string' == typeof e ||
                'number' == typeof e ||
                ('object' == typeof e && '.sv' in e),
            'Invalid priority type found: ' + typeof e
        ),
        'object' !=
            typeof (i =
                'object' == typeof i && '.value' in i && null !== i['.value']
                    ? i['.value']
                    : i) || '.sv' in i)
    ) {
        var t = i;
        return new LeafNode(t, nodeFromJSON(e));
    }
    if (i instanceof Array || !USE_HINZE) {
        let r = ChildrenNode.EMPTY_NODE;
        return (
            each(i, (e, t) => {
                if (contains(i, e) && '.' !== e.substring(0, 1)) {
                    const n = nodeFromJSON(t);
                    (!n.isLeafNode() && n.isEmpty()) ||
                        (r = r.updateImmediateChild(e, n));
                }
            }),
            r.updatePriority(nodeFromJSON(e))
        );
    }
    {
        const o = [];
        let r = !1;
        if (
            (each(i, (e, t) => {
                if ('.' !== e.substring(0, 1)) {
                    const n = nodeFromJSON(t);
                    n.isEmpty() ||
                        ((r = r || !n.getPriority().isEmpty()),
                        o.push(new NamedNode(e, n)));
                }
            }),
            0 === o.length)
        )
            return ChildrenNode.EMPTY_NODE;
        var n = buildChildSet(
            o,
            NAME_ONLY_COMPARATOR,
            (e) => e.name,
            NAME_COMPARATOR
        );
        if (r) {
            t = buildChildSet(o, PRIORITY_INDEX.getCompare());
            return new ChildrenNode(
                n,
                nodeFromJSON(e),
                new IndexMap(
                    { '.priority': t },
                    { '.priority': PRIORITY_INDEX }
                )
            );
        }
        return new ChildrenNode(n, nodeFromJSON(e), IndexMap.Default);
    }
}
setNodeFromJSON(nodeFromJSON);
class PathIndex extends Index {
    constructor(e) {
        super(),
            (this.indexPath_ = e),
            assert(
                !pathIsEmpty(e) && '.priority' !== pathGetFront(e),
                "Can't create PathIndex with empty path or .priority key"
            );
    }
    extractChild(e) {
        return e.getChild(this.indexPath_);
    }
    isDefinedOn(e) {
        return !e.getChild(this.indexPath_).isEmpty();
    }
    compare(e, t) {
        const n = this.extractChild(e.node);
        var r = this.extractChild(t.node),
            r = n.compareTo(r);
        return 0 === r ? nameCompare(e.name, t.name) : r;
    }
    makePost(e, t) {
        (e = nodeFromJSON(e)),
            (e = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, e));
        return new NamedNode(t, e);
    }
    maxPost() {
        var e = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);
        return new NamedNode(MAX_NAME, e);
    }
    toString() {
        return pathSlice(this.indexPath_, 0).join('/');
    }
}
class ValueIndex extends Index {
    compare(e, t) {
        var n = e.node.compareTo(t.node);
        return 0 === n ? nameCompare(e.name, t.name) : n;
    }
    isDefinedOn(e) {
        return !0;
    }
    indexedValueChanged(e, t) {
        return !e.equals(t);
    }
    minPost() {
        return NamedNode.MIN;
    }
    maxPost() {
        return NamedNode.MAX;
    }
    makePost(e, t) {
        e = nodeFromJSON(e);
        return new NamedNode(t, e);
    }
    toString() {
        return '.value';
    }
}
const VALUE_INDEX = new ValueIndex(),
    PUSH_CHARS =
        '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz',
    MIN_PUSH_CHAR = '-',
    MAX_PUSH_CHAR = 'z',
    MAX_KEY_LEN = 786,
    nextPushId = (function () {
        let o = 0;
        const s = [];
        return function (e) {
            var t = e === o;
            o = e;
            let n;
            const r = new Array(8);
            for (n = 7; 0 <= n; n--)
                (r[n] = PUSH_CHARS.charAt(e % 64)), (e = Math.floor(e / 64));
            assert(0 === e, 'Cannot push at time == 0');
            let i = r.join('');
            if (t) {
                for (n = 11; 0 <= n && 63 === s[n]; n--) s[n] = 0;
                s[n]++;
            } else
                for (n = 0; n < 12; n++) s[n] = Math.floor(64 * Math.random());
            for (n = 0; n < 12; n++) i += PUSH_CHARS.charAt(s[n]);
            return (
                assert(20 === i.length, 'nextPushId: Length should be 20.'), i
            );
        };
    })(),
    successor = function (t) {
        if (t === '' + INTEGER_32_MAX) return MIN_PUSH_CHAR;
        var e = tryParseInt(t);
        if (null != e) return '' + (e + 1);
        const n = new Array(t.length);
        for (let e = 0; e < n.length; e++) n[e] = t.charAt(e);
        if (n.length < MAX_KEY_LEN) return n.push(MIN_PUSH_CHAR), n.join('');
        let r = n.length - 1;
        for (; 0 <= r && n[r] === MAX_PUSH_CHAR; ) r--;
        if (-1 === r) return MAX_NAME;
        (e = n[r]), (e = PUSH_CHARS.charAt(PUSH_CHARS.indexOf(e) + 1));
        return (n[r] = e), n.slice(0, r + 1).join('');
    },
    predecessor = function (t) {
        if (t === '' + INTEGER_32_MIN) return MIN_NAME;
        var e = tryParseInt(t);
        if (null != e) return '' + (e - 1);
        const n = new Array(t.length);
        for (let e = 0; e < n.length; e++) n[e] = t.charAt(e);
        return n[n.length - 1] === MIN_PUSH_CHAR
            ? 1 === n.length
                ? '' + INTEGER_32_MAX
                : (delete n[n.length - 1], n.join(''))
            : ((n[n.length - 1] = PUSH_CHARS.charAt(
                  PUSH_CHARS.indexOf(n[n.length - 1]) - 1
              )),
              n.join('') + MAX_PUSH_CHAR.repeat(MAX_KEY_LEN - n.length));
    };
function changeValue(e) {
    return { type: 'value', snapshotNode: e };
}
function changeChildAdded(e, t) {
    return { type: 'child_added', snapshotNode: t, childName: e };
}
function changeChildRemoved(e, t) {
    return { type: 'child_removed', snapshotNode: t, childName: e };
}
function changeChildChanged(e, t, n) {
    return { type: 'child_changed', snapshotNode: t, childName: e, oldSnap: n };
}
function changeChildMoved(e, t) {
    return { type: 'child_moved', snapshotNode: t, childName: e };
}
class IndexedFilter {
    constructor(e) {
        this.index_ = e;
    }
    updateChild(e, t, n, r, i, o) {
        assert(
            e.isIndexed(this.index_),
            'A node must be indexed if only a child is updated'
        );
        const s = e.getImmediateChild(t);
        return s.getChild(r).equals(n.getChild(r)) &&
            s.isEmpty() === n.isEmpty()
            ? e
            : (null != o &&
                  (n.isEmpty()
                      ? e.hasChild(t)
                          ? o.trackChildChange(changeChildRemoved(t, s))
                          : assert(
                                e.isLeafNode(),
                                'A child remove without an old child only makes sense on a leaf node'
                            )
                      : s.isEmpty()
                      ? o.trackChildChange(changeChildAdded(t, n))
                      : o.trackChildChange(changeChildChanged(t, n, s))),
              e.isLeafNode() && n.isEmpty()
                  ? e
                  : e.updateImmediateChild(t, n).withIndex(this.index_));
    }
    updateFullNode(r, n, i) {
        return (
            null != i &&
                (r.isLeafNode() ||
                    r.forEachChild(PRIORITY_INDEX, (e, t) => {
                        n.hasChild(e) ||
                            i.trackChildChange(changeChildRemoved(e, t));
                    }),
                n.isLeafNode() ||
                    n.forEachChild(PRIORITY_INDEX, (e, t) => {
                        if (r.hasChild(e)) {
                            const n = r.getImmediateChild(e);
                            n.equals(t) ||
                                i.trackChildChange(changeChildChanged(e, t, n));
                        } else i.trackChildChange(changeChildAdded(e, t));
                    })),
            n.withIndex(this.index_)
        );
    }
    updatePriority(e, t) {
        return e.isEmpty() ? ChildrenNode.EMPTY_NODE : e.updatePriority(t);
    }
    filtersNodes() {
        return !1;
    }
    getIndexedFilter() {
        return this;
    }
    getIndex() {
        return this.index_;
    }
}
class RangedFilter {
    constructor(e) {
        (this.indexedFilter_ = new IndexedFilter(e.getIndex())),
            (this.index_ = e.getIndex()),
            (this.startPost_ = RangedFilter.getStartPost_(e)),
            (this.endPost_ = RangedFilter.getEndPost_(e));
    }
    getStartPost() {
        return this.startPost_;
    }
    getEndPost() {
        return this.endPost_;
    }
    matches(e) {
        return (
            this.index_.compare(this.getStartPost(), e) <= 0 &&
            this.index_.compare(e, this.getEndPost()) <= 0
        );
    }
    updateChild(e, t, n, r, i, o) {
        return (
            this.matches(new NamedNode(t, n)) || (n = ChildrenNode.EMPTY_NODE),
            this.indexedFilter_.updateChild(e, t, n, r, i, o)
        );
    }
    updateFullNode(e, t, n) {
        let r = (t = t.isLeafNode() ? ChildrenNode.EMPTY_NODE : t).withIndex(
            this.index_
        );
        r = r.updatePriority(ChildrenNode.EMPTY_NODE);
        const i = this;
        return (
            t.forEachChild(PRIORITY_INDEX, (e, t) => {
                i.matches(new NamedNode(e, t)) ||
                    (r = r.updateImmediateChild(e, ChildrenNode.EMPTY_NODE));
            }),
            this.indexedFilter_.updateFullNode(e, r, n)
        );
    }
    updatePriority(e, t) {
        return e;
    }
    filtersNodes() {
        return !0;
    }
    getIndexedFilter() {
        return this.indexedFilter_;
    }
    getIndex() {
        return this.index_;
    }
    static getStartPost_(e) {
        if (e.hasStart()) {
            var t = e.getIndexStartName();
            return e.getIndex().makePost(e.getIndexStartValue(), t);
        }
        return e.getIndex().minPost();
    }
    static getEndPost_(e) {
        if (e.hasEnd()) {
            var t = e.getIndexEndName();
            return e.getIndex().makePost(e.getIndexEndValue(), t);
        }
        return e.getIndex().maxPost();
    }
}
class LimitedFilter {
    constructor(e) {
        (this.rangedFilter_ = new RangedFilter(e)),
            (this.index_ = e.getIndex()),
            (this.limit_ = e.getLimit()),
            (this.reverse_ = !e.isViewFromLeft());
    }
    updateChild(e, t, n, r, i, o) {
        return (
            this.rangedFilter_.matches(new NamedNode(t, n)) ||
                (n = ChildrenNode.EMPTY_NODE),
            e.getImmediateChild(t).equals(n)
                ? e
                : e.numChildren() < this.limit_
                ? this.rangedFilter_
                      .getIndexedFilter()
                      .updateChild(e, t, n, r, i, o)
                : this.fullLimitUpdateChild_(e, t, n, i, o)
        );
    }
    updateFullNode(e, s, t) {
        let a;
        if (s.isLeafNode() || s.isEmpty())
            a = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
        else if (
            2 * this.limit_ < s.numChildren() &&
            s.isIndexed(this.index_)
        ) {
            a = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
            let t;
            t = this.reverse_
                ? s.getReverseIteratorFrom(
                      this.rangedFilter_.getEndPost(),
                      this.index_
                  )
                : s.getIteratorFrom(
                      this.rangedFilter_.getStartPost(),
                      this.index_
                  );
            let n = 0;
            for (; t.hasNext() && n < this.limit_; ) {
                var r = t.getNext();
                let e;
                if (
                    ((e = this.reverse_
                        ? this.index_.compare(
                              this.rangedFilter_.getStartPost(),
                              r
                          ) <= 0
                        : this.index_.compare(
                              r,
                              this.rangedFilter_.getEndPost()
                          ) <= 0),
                    !e)
                )
                    break;
                (a = a.updateImmediateChild(r.name, r.node)), n++;
            }
        } else {
            (a = s.withIndex(this.index_)),
                (a = a.updatePriority(ChildrenNode.EMPTY_NODE));
            let e, t, n, r;
            if (this.reverse_) {
                (r = a.getReverseIterator(this.index_)),
                    (e = this.rangedFilter_.getEndPost()),
                    (t = this.rangedFilter_.getStartPost());
                const h = this.index_.getCompare();
                n = (e, t) => h(t, e);
            } else
                (r = a.getIterator(this.index_)),
                    (e = this.rangedFilter_.getStartPost()),
                    (t = this.rangedFilter_.getEndPost()),
                    (n = this.index_.getCompare());
            let i = 0,
                o = !1;
            for (; r.hasNext(); ) {
                var l = r.getNext();
                !o && n(e, l) <= 0 && (o = !0),
                    o && i < this.limit_ && n(l, t) <= 0
                        ? i++
                        : (a = a.updateImmediateChild(
                              l.name,
                              ChildrenNode.EMPTY_NODE
                          ));
            }
        }
        return this.rangedFilter_.getIndexedFilter().updateFullNode(e, a, t);
    }
    updatePriority(e, t) {
        return e;
    }
    filtersNodes() {
        return !0;
    }
    getIndexedFilter() {
        return this.rangedFilter_.getIndexedFilter();
    }
    getIndex() {
        return this.index_;
    }
    fullLimitUpdateChild_(e, t, n, r, i) {
        let o;
        if (this.reverse_) {
            const u = this.index_.getCompare();
            o = (e, t) => u(t, e);
        } else o = this.index_.getCompare();
        const s = e;
        assert(s.numChildren() === this.limit_, '');
        var a = new NamedNode(t, n),
            l = this.reverse_
                ? s.getFirstChild(this.index_)
                : s.getLastChild(this.index_),
            h = this.rangedFilter_.matches(a);
        if (s.hasChild(t)) {
            var c = s.getImmediateChild(t);
            let e = r.getChildAfterChild(this.index_, l, this.reverse_);
            for (; null != e && (e.name === t || s.hasChild(e.name)); )
                e = r.getChildAfterChild(this.index_, e, this.reverse_);
            var d = null == e ? 1 : o(e, a);
            if (h && !n.isEmpty() && 0 <= d)
                return (
                    null != i &&
                        i.trackChildChange(changeChildChanged(t, n, c)),
                    s.updateImmediateChild(t, n)
                );
            {
                null != i && i.trackChildChange(changeChildRemoved(t, c));
                const p = s.updateImmediateChild(t, ChildrenNode.EMPTY_NODE);
                return null != e && this.rangedFilter_.matches(e)
                    ? (null != i &&
                          i.trackChildChange(changeChildAdded(e.name, e.node)),
                      p.updateImmediateChild(e.name, e.node))
                    : p;
            }
        }
        return !n.isEmpty() && h && 0 <= o(l, a)
            ? (null != i &&
                  (i.trackChildChange(changeChildRemoved(l.name, l.node)),
                  i.trackChildChange(changeChildAdded(t, n))),
              s
                  .updateImmediateChild(t, n)
                  .updateImmediateChild(l.name, ChildrenNode.EMPTY_NODE))
            : e;
    }
}
class QueryParams {
    constructor() {
        (this.limitSet_ = !1),
            (this.startSet_ = !1),
            (this.startNameSet_ = !1),
            (this.startAfterSet_ = !1),
            (this.endSet_ = !1),
            (this.endNameSet_ = !1),
            (this.endBeforeSet_ = !1),
            (this.limit_ = 0),
            (this.viewFrom_ = ''),
            (this.indexStartValue_ = null),
            (this.indexStartName_ = ''),
            (this.indexEndValue_ = null),
            (this.indexEndName_ = ''),
            (this.index_ = PRIORITY_INDEX);
    }
    hasStart() {
        return this.startSet_;
    }
    hasStartAfter() {
        return this.startAfterSet_;
    }
    hasEndBefore() {
        return this.endBeforeSet_;
    }
    isViewFromLeft() {
        return '' === this.viewFrom_ ? this.startSet_ : 'l' === this.viewFrom_;
    }
    getIndexStartValue() {
        return (
            assert(this.startSet_, 'Only valid if start has been set'),
            this.indexStartValue_
        );
    }
    getIndexStartName() {
        return (
            assert(this.startSet_, 'Only valid if start has been set'),
            this.startNameSet_ ? this.indexStartName_ : MIN_NAME
        );
    }
    hasEnd() {
        return this.endSet_;
    }
    getIndexEndValue() {
        return (
            assert(this.endSet_, 'Only valid if end has been set'),
            this.indexEndValue_
        );
    }
    getIndexEndName() {
        return (
            assert(this.endSet_, 'Only valid if end has been set'),
            this.endNameSet_ ? this.indexEndName_ : MAX_NAME
        );
    }
    hasLimit() {
        return this.limitSet_;
    }
    hasAnchoredLimit() {
        return this.limitSet_ && '' !== this.viewFrom_;
    }
    getLimit() {
        return (
            assert(this.limitSet_, 'Only valid if limit has been set'),
            this.limit_
        );
    }
    getIndex() {
        return this.index_;
    }
    loadsAllData() {
        return !(this.startSet_ || this.endSet_ || this.limitSet_);
    }
    isDefault() {
        return this.loadsAllData() && this.index_ === PRIORITY_INDEX;
    }
    copy() {
        const e = new QueryParams();
        return (
            (e.limitSet_ = this.limitSet_),
            (e.limit_ = this.limit_),
            (e.startSet_ = this.startSet_),
            (e.indexStartValue_ = this.indexStartValue_),
            (e.startNameSet_ = this.startNameSet_),
            (e.indexStartName_ = this.indexStartName_),
            (e.endSet_ = this.endSet_),
            (e.indexEndValue_ = this.indexEndValue_),
            (e.endNameSet_ = this.endNameSet_),
            (e.indexEndName_ = this.indexEndName_),
            (e.index_ = this.index_),
            (e.viewFrom_ = this.viewFrom_),
            e
        );
    }
}
function queryParamsGetNodeFilter(e) {
    return e.loadsAllData()
        ? new IndexedFilter(e.getIndex())
        : new (e.hasLimit() ? LimitedFilter : RangedFilter)(e);
}
function queryParamsLimitToFirst(e, t) {
    const n = e.copy();
    return (n.limitSet_ = !0), (n.limit_ = t), (n.viewFrom_ = 'l'), n;
}
function queryParamsLimitToLast(e, t) {
    const n = e.copy();
    return (n.limitSet_ = !0), (n.limit_ = t), (n.viewFrom_ = 'r'), n;
}
function queryParamsStartAt(e, t, n) {
    const r = e.copy();
    return (
        (r.startSet_ = !0),
        void 0 === t && (t = null),
        (r.indexStartValue_ = t),
        null != n
            ? ((r.startNameSet_ = !0), (r.indexStartName_ = n))
            : ((r.startNameSet_ = !1), (r.indexStartName_ = '')),
        r
    );
}
function queryParamsStartAfter(t, n, r) {
    let i;
    if (t.index_ === KEY_INDEX)
        'string' == typeof n && (n = successor(n)),
            (i = queryParamsStartAt(t, n, r));
    else {
        let e;
        (e = null == r ? MAX_NAME : successor(r)),
            (i = queryParamsStartAt(t, n, e));
    }
    return (i.startAfterSet_ = !0), i;
}
function queryParamsEndAt(e, t, n) {
    const r = e.copy();
    return (
        (r.endSet_ = !0),
        void 0 === t && (t = null),
        (r.indexEndValue_ = t),
        void 0 !== n
            ? ((r.endNameSet_ = !0), (r.indexEndName_ = n))
            : ((r.endNameSet_ = !1), (r.indexEndName_ = '')),
        r
    );
}
function queryParamsEndBefore(e, t, n) {
    let r, i;
    return (
        (i =
            e.index_ === KEY_INDEX
                ? queryParamsEndAt(
                      e,
                      (t = 'string' == typeof t ? predecessor(t) : t),
                      n
                  )
                : ((r = null == n ? MIN_NAME : predecessor(n)),
                  queryParamsEndAt(e, t, r))),
        (i.endBeforeSet_ = !0),
        i
    );
}
function queryParamsOrderBy(e, t) {
    const n = e.copy();
    return (n.index_ = t), n;
}
function queryParamsToRestQueryStringParameters(e) {
    const t = {};
    if (e.isDefault()) return t;
    let n;
    return (
        (n =
            e.index_ === PRIORITY_INDEX
                ? '$priority'
                : e.index_ === VALUE_INDEX
                ? '$value'
                : e.index_ === KEY_INDEX
                ? '$key'
                : (assert(
                      e.index_ instanceof PathIndex,
                      'Unrecognized index type!'
                  ),
                  e.index_.toString())),
        (t.orderBy = stringify(n)),
        e.startSet_ &&
            ((t.startAt = stringify(e.indexStartValue_)),
            e.startNameSet_ &&
                (t.startAt += ',' + stringify(e.indexStartName_))),
        e.endSet_ &&
            ((t.endAt = stringify(e.indexEndValue_)),
            e.endNameSet_ && (t.endAt += ',' + stringify(e.indexEndName_))),
        e.limitSet_ &&
            (e.isViewFromLeft()
                ? (t.limitToFirst = e.limit_)
                : (t.limitToLast = e.limit_)),
        t
    );
}
function queryParamsGetQueryObject(t) {
    const n = {};
    if (
        (t.startSet_ &&
            ((n.sp = t.indexStartValue_),
            t.startNameSet_ && (n.sn = t.indexStartName_)),
        t.endSet_ &&
            ((n.ep = t.indexEndValue_),
            t.endNameSet_ && (n.en = t.indexEndName_)),
        t.limitSet_)
    ) {
        n.l = t.limit_;
        let e = t.viewFrom_;
        '' === e && (e = t.isViewFromLeft() ? 'l' : 'r'), (n.vf = e);
    }
    return t.index_ !== PRIORITY_INDEX && (n.i = t.index_.toString()), n;
}
class ReadonlyRestClient extends ServerActions {
    constructor(e, t, n, r) {
        super(),
            (this.repoInfo_ = e),
            (this.onDataUpdate_ = t),
            (this.authTokenProvider_ = n),
            (this.appCheckTokenProvider_ = r),
            (this.log_ = logWrapper('p:rest:')),
            (this.listens_ = {});
    }
    reportStats(e) {
        throw new Error('Method not implemented.');
    }
    static getListenId_(e, t) {
        return void 0 !== t
            ? 'tag$' + t
            : (assert(
                  e._queryParams.isDefault(),
                  "should have a tag if it's not a default query."
              ),
              e._path.toString());
    }
    listen(e, t, r, i) {
        const o = e._path.toString();
        this.log_('Listen called for ' + o + ' ' + e._queryIdentifier);
        const s = ReadonlyRestClient.getListenId_(e, r),
            a = {};
        this.listens_[s] = a;
        e = queryParamsToRestQueryStringParameters(e._queryParams);
        this.restRequest_(o + '.json', e, (t, e) => {
            let n = e;
            if (
                (null === (t = 404 === t ? (n = null) : t) &&
                    this.onDataUpdate_(o, n, !1, r),
                safeGet(this.listens_, s) === a)
            ) {
                let e;
                (e = t
                    ? 401 === t
                        ? 'permission_denied'
                        : 'rest_error:' + t
                    : 'ok'),
                    i(e, null);
            }
        });
    }
    unlisten(e, t) {
        t = ReadonlyRestClient.getListenId_(e, t);
        delete this.listens_[t];
    }
    get(e) {
        var t = queryParamsToRestQueryStringParameters(e._queryParams);
        const r = e._path.toString(),
            i = new Deferred();
        return (
            this.restRequest_(r + '.json', t, (e, t) => {
                let n = t;
                null === (e = 404 === e ? (n = null) : e)
                    ? (this.onDataUpdate_(r, n, !1, null), i.resolve(n))
                    : i.reject(new Error(n));
            }),
            i.promise
        );
    }
    refreshAuthToken(e) {}
    restRequest_(i, o = {}, s) {
        return (
            (o.format = 'export'),
            Promise.all([
                this.authTokenProvider_.getToken(!1),
                this.appCheckTokenProvider_.getToken(!1),
            ]).then(([e, t]) => {
                e && e.accessToken && (o.auth = e.accessToken),
                    t && t.token && (o.ac = t.token);
                const n =
                    (this.repoInfo_.secure ? 'https://' : 'http://') +
                    this.repoInfo_.host +
                    i +
                    '?ns=' +
                    this.repoInfo_.namespace +
                    querystring(o);
                this.log_('Sending REST request for ' + n);
                const r = new XMLHttpRequest();
                (r.onreadystatechange = () => {
                    if (s && 4 === r.readyState) {
                        this.log_(
                            'REST Response for ' + n + ' received. status:',
                            r.status,
                            'response:',
                            r.responseText
                        );
                        let e = null;
                        if (200 <= r.status && r.status < 300) {
                            try {
                                e = jsonEval(r.responseText);
                            } catch (e) {
                                warn(
                                    'Failed to parse JSON response for ' +
                                        n +
                                        ': ' +
                                        r.responseText
                                );
                            }
                            s(null, e);
                        } else
                            401 !== r.status &&
                                404 !== r.status &&
                                warn(
                                    'Got unsuccessful REST response for ' +
                                        n +
                                        ' Status: ' +
                                        r.status
                                ),
                                s(r.status);
                        s = null;
                    }
                }),
                    r.open('GET', n, !0),
                    r.send();
            })
        );
    }
}
class SnapshotHolder {
    constructor() {
        this.rootNode_ = ChildrenNode.EMPTY_NODE;
    }
    getNode(e) {
        return this.rootNode_.getChild(e);
    }
    updateSnapshot(e, t) {
        this.rootNode_ = this.rootNode_.updateChild(e, t);
    }
}
function newSparseSnapshotTree() {
    return { value: null, children: new Map() };
}
function sparseSnapshotTreeRemember(e, t, n) {
    var r;
    pathIsEmpty(t)
        ? ((e.value = n), e.children.clear())
        : null !== e.value
        ? (e.value = e.value.updateChild(t, n))
        : ((r = pathGetFront(t)),
          e.children.has(r) || e.children.set(r, newSparseSnapshotTree()),
          sparseSnapshotTreeRemember(
              e.children.get(r),
              (t = pathPopFront(t)),
              n
          ));
}
function sparseSnapshotTreeForget(n, e) {
    if (pathIsEmpty(e)) return (n.value = null), n.children.clear(), !0;
    if (null !== n.value) {
        if (n.value.isLeafNode()) return !1;
        {
            const r = n.value;
            return (
                (n.value = null),
                r.forEachChild(PRIORITY_INDEX, (e, t) => {
                    sparseSnapshotTreeRemember(n, new Path(e), t);
                }),
                sparseSnapshotTreeForget(n, e)
            );
        }
    }
    if (0 < n.children.size) {
        var t = pathGetFront(e);
        return (
            (e = pathPopFront(e)),
            n.children.has(t) &&
                sparseSnapshotTreeForget(n.children.get(t), e) &&
                n.children.delete(t),
            0 === n.children.size
        );
    }
    return !0;
}
function sparseSnapshotTreeForEachTree(e, n, r) {
    null !== e.value
        ? r(n, e.value)
        : sparseSnapshotTreeForEachChild(e, (e, t) => {
              sparseSnapshotTreeForEachTree(
                  t,
                  new Path(n.toString() + '/' + e),
                  r
              );
          });
}
function sparseSnapshotTreeForEachChild(e, n) {
    e.children.forEach((e, t) => {
        n(t, e);
    });
}
class StatsListener {
    constructor(e) {
        (this.collection_ = e), (this.last_ = null);
    }
    get() {
        var e = this.collection_.get();
        const n = Object.assign({}, e);
        return (
            this.last_ &&
                each(this.last_, (e, t) => {
                    n[e] = n[e] - t;
                }),
            (this.last_ = e),
            n
        );
    }
}
const FIRST_STATS_MIN_TIME = 1e4,
    FIRST_STATS_MAX_TIME = 3e4,
    REPORT_STATS_INTERVAL = 3e5;
class StatsReporter {
    constructor(e, t) {
        (this.server_ = t),
            (this.statsToReport_ = {}),
            (this.statsListener_ = new StatsListener(e));
        e =
            FIRST_STATS_MIN_TIME +
            (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(e));
    }
    reportStats_() {
        var e = this.statsListener_.get();
        const n = {};
        let r = !1;
        each(e, (e, t) => {
            0 < t && contains(this.statsToReport_, e) && ((n[e] = t), (r = !0));
        }),
            r && this.server_.reportStats(n),
            setTimeoutNonBlocking(
                this.reportStats_.bind(this),
                Math.floor(2 * Math.random() * REPORT_STATS_INTERVAL)
            );
    }
}
function newOperationSourceUser() {
    return { fromUser: !0, fromServer: !1, queryId: null, tagged: !1 };
}
function newOperationSourceServer() {
    return { fromUser: !1, fromServer: !0, queryId: null, tagged: !1 };
}
function newOperationSourceServerTaggedQuery(e) {
    return { fromUser: !1, fromServer: !0, queryId: e, tagged: !0 };
}
!(function (e) {
    (e[(e.OVERWRITE = 0)] = 'OVERWRITE'),
        (e[(e.MERGE = 1)] = 'MERGE'),
        (e[(e.ACK_USER_WRITE = 2)] = 'ACK_USER_WRITE'),
        (e[(e.LISTEN_COMPLETE = 3)] = 'LISTEN_COMPLETE');
})((OperationType = OperationType || {}));
class AckUserWrite {
    constructor(e, t, n) {
        (this.path = e),
            (this.affectedTree = t),
            (this.revert = n),
            (this.type = OperationType.ACK_USER_WRITE),
            (this.source = newOperationSourceUser());
    }
    operationForChild(e) {
        if (pathIsEmpty(this.path)) {
            if (null != this.affectedTree.value)
                return (
                    assert(
                        this.affectedTree.children.isEmpty(),
                        'affectedTree should not have overlapping affected paths.'
                    ),
                    this
                );
            var t = this.affectedTree.subtree(new Path(e));
            return new AckUserWrite(newEmptyPath(), t, this.revert);
        }
        return (
            assert(
                pathGetFront(this.path) === e,
                'operationForChild called for unrelated child.'
            ),
            new AckUserWrite(
                pathPopFront(this.path),
                this.affectedTree,
                this.revert
            )
        );
    }
}
class ListenComplete {
    constructor(e, t) {
        (this.source = e),
            (this.path = t),
            (this.type = OperationType.LISTEN_COMPLETE);
    }
    operationForChild(e) {
        return pathIsEmpty(this.path)
            ? new ListenComplete(this.source, newEmptyPath())
            : new ListenComplete(this.source, pathPopFront(this.path));
    }
}
class Overwrite {
    constructor(e, t, n) {
        (this.source = e),
            (this.path = t),
            (this.snap = n),
            (this.type = OperationType.OVERWRITE);
    }
    operationForChild(e) {
        return pathIsEmpty(this.path)
            ? new Overwrite(
                  this.source,
                  newEmptyPath(),
                  this.snap.getImmediateChild(e)
              )
            : new Overwrite(this.source, pathPopFront(this.path), this.snap);
    }
}
class Merge {
    constructor(e, t, n) {
        (this.source = e),
            (this.path = t),
            (this.children = n),
            (this.type = OperationType.MERGE);
    }
    operationForChild(e) {
        if (pathIsEmpty(this.path)) {
            const t = this.children.subtree(new Path(e));
            return t.isEmpty()
                ? null
                : t.value
                ? new Overwrite(this.source, newEmptyPath(), t.value)
                : new Merge(this.source, newEmptyPath(), t);
        }
        return (
            assert(
                pathGetFront(this.path) === e,
                "Can't get a merge for a child not on the path of the operation"
            ),
            new Merge(this.source, pathPopFront(this.path), this.children)
        );
    }
    toString() {
        return (
            'Operation(' +
            this.path +
            ': ' +
            this.source.toString() +
            ' merge: ' +
            this.children.toString() +
            ')'
        );
    }
}
class CacheNode {
    constructor(e, t, n) {
        (this.node_ = e), (this.fullyInitialized_ = t), (this.filtered_ = n);
    }
    isFullyInitialized() {
        return this.fullyInitialized_;
    }
    isFiltered() {
        return this.filtered_;
    }
    isCompleteForPath(e) {
        if (pathIsEmpty(e)) return this.isFullyInitialized() && !this.filtered_;
        e = pathGetFront(e);
        return this.isCompleteForChild(e);
    }
    isCompleteForChild(e) {
        return (
            (this.isFullyInitialized() && !this.filtered_) ||
            this.node_.hasChild(e)
        );
    }
    getNode() {
        return this.node_;
    }
}
class EventGenerator {
    constructor(e) {
        (this.query_ = e), (this.index_ = this.query_._queryParams.getIndex());
    }
}
function eventGeneratorGenerateEventsForChanges(t, e, n, r) {
    var i = [];
    const o = [];
    return (
        e.forEach((e) => {
            'child_changed' === e.type &&
                t.index_.indexedValueChanged(e.oldSnap, e.snapshotNode) &&
                o.push(changeChildMoved(e.childName, e.snapshotNode));
        }),
        eventGeneratorGenerateEventsForType(t, i, 'child_removed', e, r, n),
        eventGeneratorGenerateEventsForType(t, i, 'child_added', e, r, n),
        eventGeneratorGenerateEventsForType(t, i, 'child_moved', o, r, n),
        eventGeneratorGenerateEventsForType(t, i, 'child_changed', e, r, n),
        eventGeneratorGenerateEventsForType(t, i, 'value', e, r, n),
        i
    );
}
function eventGeneratorGenerateEventsForType(r, i, t, e, o, s) {
    const n = e.filter((e) => e.type === t);
    n.sort((e, t) => eventGeneratorCompareChanges(r, e, t)),
        n.forEach((t) => {
            const n = eventGeneratorMaterializeSingleChange(r, t, s);
            o.forEach((e) => {
                e.respondsTo(t.type) && i.push(e.createEvent(n, r.query_));
            });
        });
}
function eventGeneratorMaterializeSingleChange(e, t, n) {
    return (
        'value' === t.type ||
            'child_removed' === t.type ||
            (t.prevName = n.getPredecessorChildName(
                t.childName,
                t.snapshotNode,
                e.index_
            )),
        t
    );
}
function eventGeneratorCompareChanges(e, t, n) {
    if (null == t.childName || null == n.childName)
        throw assertionError('Should only compare child_ events.');
    (t = new NamedNode(t.childName, t.snapshotNode)),
        (n = new NamedNode(n.childName, n.snapshotNode));
    return e.index_.compare(t, n);
}
function newViewCache(e, t) {
    return { eventCache: e, serverCache: t };
}
function viewCacheUpdateEventSnap(e, t, n, r) {
    return newViewCache(new CacheNode(t, n, r), e.serverCache);
}
function viewCacheUpdateServerSnap(e, t, n, r) {
    return newViewCache(e.eventCache, new CacheNode(t, n, r));
}
function viewCacheGetCompleteEventSnap(e) {
    return e.eventCache.isFullyInitialized() ? e.eventCache.getNode() : null;
}
function viewCacheGetCompleteServerSnap(e) {
    return e.serverCache.isFullyInitialized() ? e.serverCache.getNode() : null;
}
let emptyChildrenSingleton;
const EmptyChildren = () => (
    (emptyChildrenSingleton =
        emptyChildrenSingleton || new SortedMap(stringCompare)),
    emptyChildrenSingleton
);
class ImmutableTree {
    constructor(e, t = EmptyChildren()) {
        (this.value = e), (this.children = t);
    }
    static fromObject(e) {
        let n = new ImmutableTree(null);
        return (
            each(e, (e, t) => {
                n = n.set(new Path(e), t);
            }),
            n
        );
    }
    isEmpty() {
        return null === this.value && this.children.isEmpty();
    }
    findRootMostMatchingPathAndValue(e, t) {
        if (null != this.value && t(this.value))
            return { path: newEmptyPath(), value: this.value };
        if (pathIsEmpty(e)) return null;
        {
            var n = pathGetFront(e);
            const r = this.children.get(n);
            if (null === r) return null;
            t = r.findRootMostMatchingPathAndValue(pathPopFront(e), t);
            return null == t
                ? null
                : { path: pathChild(new Path(n), t.path), value: t.value };
        }
    }
    findRootMostValueAndPath(e) {
        return this.findRootMostMatchingPathAndValue(e, () => !0);
    }
    subtree(e) {
        if (pathIsEmpty(e)) return this;
        {
            var t = pathGetFront(e);
            const n = this.children.get(t);
            return null !== n
                ? n.subtree(pathPopFront(e))
                : new ImmutableTree(null);
        }
    }
    set(e, t) {
        if (pathIsEmpty(e)) return new ImmutableTree(t, this.children);
        {
            var n = pathGetFront(e);
            const r = this.children.get(n) || new ImmutableTree(null);
            (t = r.set(pathPopFront(e), t)), (t = this.children.insert(n, t));
            return new ImmutableTree(this.value, t);
        }
    }
    remove(t) {
        if (pathIsEmpty(t))
            return this.children.isEmpty()
                ? new ImmutableTree(null)
                : new ImmutableTree(null, this.children);
        {
            var n = pathGetFront(t);
            const r = this.children.get(n);
            if (r) {
                const i = r.remove(pathPopFront(t));
                let e;
                return (
                    (e = i.isEmpty()
                        ? this.children.remove(n)
                        : this.children.insert(n, i)),
                    null === this.value && e.isEmpty()
                        ? new ImmutableTree(null)
                        : new ImmutableTree(this.value, e)
                );
            }
            return this;
        }
    }
    get(e) {
        if (pathIsEmpty(e)) return this.value;
        {
            var t = pathGetFront(e);
            const n = this.children.get(t);
            return n ? n.get(pathPopFront(e)) : null;
        }
    }
    setTree(t, n) {
        if (pathIsEmpty(t)) return n;
        {
            var r = pathGetFront(t);
            const i = this.children.get(r) || new ImmutableTree(null),
                o = i.setTree(pathPopFront(t), n);
            let e;
            return (
                (e = o.isEmpty()
                    ? this.children.remove(r)
                    : this.children.insert(r, o)),
                new ImmutableTree(this.value, e)
            );
        }
    }
    fold(e) {
        return this.fold_(newEmptyPath(), e);
    }
    fold_(n, r) {
        const i = {};
        return (
            this.children.inorderTraversal((e, t) => {
                i[e] = t.fold_(pathChild(n, e), r);
            }),
            r(n, this.value, i)
        );
    }
    findOnPath(e, t) {
        return this.findOnPath_(e, newEmptyPath(), t);
    }
    findOnPath_(e, t, n) {
        var r = !!this.value && n(t, this.value);
        if (r) return r;
        if (pathIsEmpty(e)) return null;
        {
            r = pathGetFront(e);
            const i = this.children.get(r);
            return i
                ? i.findOnPath_(pathPopFront(e), pathChild(t, r), n)
                : null;
        }
    }
    foreachOnPath(e, t) {
        return this.foreachOnPath_(e, newEmptyPath(), t);
    }
    foreachOnPath_(e, t, n) {
        if (pathIsEmpty(e)) return this;
        {
            this.value && n(t, this.value);
            var r = pathGetFront(e);
            const i = this.children.get(r);
            return i
                ? i.foreachOnPath_(pathPopFront(e), pathChild(t, r), n)
                : new ImmutableTree(null);
        }
    }
    foreach(e) {
        this.foreach_(newEmptyPath(), e);
    }
    foreach_(n, r) {
        this.children.inorderTraversal((e, t) => {
            t.foreach_(pathChild(n, e), r);
        }),
            this.value && r(n, this.value);
    }
    foreachChild(n) {
        this.children.inorderTraversal((e, t) => {
            t.value && n(e, t.value);
        });
    }
}
class CompoundWrite {
    constructor(e) {
        this.writeTree_ = e;
    }
    static empty() {
        return new CompoundWrite(new ImmutableTree(null));
    }
}
function compoundWriteAddWrite(t, n, r) {
    if (pathIsEmpty(n)) return new CompoundWrite(new ImmutableTree(r));
    var i = t.writeTree_.findRootMostValueAndPath(n);
    if (null != i) {
        var o = i.path;
        let e = i.value;
        i = newRelativePath(o, n);
        return (
            (e = e.updateChild(i, r)), new CompoundWrite(t.writeTree_.set(o, e))
        );
    }
    (r = new ImmutableTree(r)), (r = t.writeTree_.setTree(n, r));
    return new CompoundWrite(r);
}
function compoundWriteAddWrites(e, n, t) {
    let r = e;
    return (
        each(t, (e, t) => {
            r = compoundWriteAddWrite(r, pathChild(n, e), t);
        }),
        r
    );
}
function compoundWriteRemoveWrite(e, t) {
    if (pathIsEmpty(t)) return CompoundWrite.empty();
    t = e.writeTree_.setTree(t, new ImmutableTree(null));
    return new CompoundWrite(t);
}
function compoundWriteHasCompleteWrite(e, t) {
    return null != compoundWriteGetCompleteNode(e, t);
}
function compoundWriteGetCompleteNode(e, t) {
    var n = e.writeTree_.findRootMostValueAndPath(t);
    return null != n
        ? e.writeTree_.get(n.path).getChild(newRelativePath(n.path, t))
        : null;
}
function compoundWriteGetCompleteChildren(e) {
    const n = [],
        t = e.writeTree_.value;
    return (
        null != t
            ? t.isLeafNode() ||
              t.forEachChild(PRIORITY_INDEX, (e, t) => {
                  n.push(new NamedNode(e, t));
              })
            : e.writeTree_.children.inorderTraversal((e, t) => {
                  null != t.value && n.push(new NamedNode(e, t.value));
              }),
        n
    );
}
function compoundWriteChildCompoundWrite(e, t) {
    if (pathIsEmpty(t)) return e;
    var n = compoundWriteGetCompleteNode(e, t);
    return null != n
        ? new CompoundWrite(new ImmutableTree(n))
        : new CompoundWrite(e.writeTree_.subtree(t));
}
function compoundWriteIsEmpty(e) {
    return e.writeTree_.isEmpty();
}
function compoundWriteApply(e, t) {
    return applySubtreeWrite(newEmptyPath(), e.writeTree_, t);
}
function applySubtreeWrite(r, e, i) {
    if (null != e.value) return i.updateChild(r, e.value);
    {
        let n = null;
        return (
            e.children.inorderTraversal((e, t) => {
                '.priority' === e
                    ? (assert(
                          null !== t.value,
                          'Priority writes must always be leaf nodes'
                      ),
                      (n = t.value))
                    : (i = applySubtreeWrite(pathChild(r, e), t, i));
            }),
            (i =
                !i.getChild(r).isEmpty() && null !== n
                    ? i.updateChild(pathChild(r, '.priority'), n)
                    : i)
        );
    }
}
function writeTreeChildWrites(e, t) {
    return newWriteTreeRef(t, e);
}
function writeTreeAddOverwrite(e, t, n, r, i) {
    assert(r > e.lastWriteId, 'Stacking an older write on top of newer ones'),
        e.allWrites.push({
            path: t,
            snap: n,
            writeId: r,
            visible: (i = void 0 === i ? !0 : i),
        }),
        i && (e.visibleWrites = compoundWriteAddWrite(e.visibleWrites, t, n)),
        (e.lastWriteId = r);
}
function writeTreeAddMerge(e, t, n, r) {
    assert(r > e.lastWriteId, 'Stacking an older merge on top of newer ones'),
        e.allWrites.push({ path: t, children: n, writeId: r, visible: !0 }),
        (e.visibleWrites = compoundWriteAddWrites(e.visibleWrites, t, n)),
        (e.lastWriteId = r);
}
function writeTreeGetWrite(t, n) {
    for (let e = 0; e < t.allWrites.length; e++) {
        var r = t.allWrites[e];
        if (r.writeId === n) return r;
    }
    return null;
}
function writeTreeRemoveWrite(t, n) {
    var e = t.allWrites.findIndex((e) => e.writeId === n);
    assert(0 <= e, 'removeWrite called with nonexistent writeId.');
    const r = t.allWrites[e];
    t.allWrites.splice(e, 1);
    let i = r.visible,
        o = !1,
        s = t.allWrites.length - 1;
    for (; i && 0 <= s; ) {
        var a = t.allWrites[s];
        a.visible &&
            (s >= e && writeTreeRecordContainsPath_(a, r.path)
                ? (i = !1)
                : pathContains(r.path, a.path) && (o = !0)),
            s--;
    }
    return (
        !!i &&
        (o
            ? writeTreeResetTree_(t)
            : r.snap
            ? (t.visibleWrites = compoundWriteRemoveWrite(
                  t.visibleWrites,
                  r.path
              ))
            : each(r.children, (e) => {
                  t.visibleWrites = compoundWriteRemoveWrite(
                      t.visibleWrites,
                      pathChild(r.path, e)
                  );
              }),
        !0)
    );
}
function writeTreeRecordContainsPath_(e, t) {
    if (e.snap) return pathContains(e.path, t);
    for (const n in e.children)
        if (
            e.children.hasOwnProperty(n) &&
            pathContains(pathChild(e.path, n), t)
        )
            return !0;
    return !1;
}
function writeTreeResetTree_(e) {
    (e.visibleWrites = writeTreeLayerTree_(
        e.allWrites,
        writeTreeDefaultFilter_,
        newEmptyPath()
    )),
        0 < e.allWrites.length
            ? (e.lastWriteId = e.allWrites[e.allWrites.length - 1].writeId)
            : (e.lastWriteId = -1);
}
function writeTreeDefaultFilter_(e) {
    return e.visible;
}
function writeTreeLayerTree_(t, n, r) {
    let i = CompoundWrite.empty();
    for (let e = 0; e < t.length; ++e) {
        const s = t[e];
        if (n(s)) {
            var o = s.path;
            let e;
            if (s.snap)
                pathContains(r, o)
                    ? ((e = newRelativePath(r, o)),
                      (i = compoundWriteAddWrite(i, e, s.snap)))
                    : pathContains(o, r) &&
                      ((e = newRelativePath(o, r)),
                      (i = compoundWriteAddWrite(
                          i,
                          newEmptyPath(),
                          s.snap.getChild(e)
                      )));
            else {
                if (!s.children)
                    throw assertionError(
                        'WriteRecord should have .snap or .children'
                    );
                if (pathContains(r, o))
                    (e = newRelativePath(r, o)),
                        (i = compoundWriteAddWrites(i, e, s.children));
                else if (pathContains(o, r))
                    if (((e = newRelativePath(o, r)), pathIsEmpty(e)))
                        i = compoundWriteAddWrites(
                            i,
                            newEmptyPath(),
                            s.children
                        );
                    else {
                        const a = safeGet(s.children, pathGetFront(e));
                        a &&
                            ((o = a.getChild(pathPopFront(e))),
                            (i = compoundWriteAddWrite(i, newEmptyPath(), o)));
                    }
            }
        }
    }
    return i;
}
function writeTreeCalcCompleteEventCache(e, t, n, r, i) {
    if (r || i) {
        var o = compoundWriteChildCompoundWrite(e.visibleWrites, t);
        if (!i && compoundWriteIsEmpty(o)) return n;
        if (i || null != n || compoundWriteHasCompleteWrite(o, newEmptyPath()))
            return compoundWriteApply(
                writeTreeLayerTree_(
                    e.allWrites,
                    function (e) {
                        return (
                            (e.visible || i) &&
                            (!r || !~r.indexOf(e.writeId)) &&
                            (pathContains(e.path, t) || pathContains(t, e.path))
                        );
                    },
                    t
                ),
                n || ChildrenNode.EMPTY_NODE
            );
        return null;
    }
    o = compoundWriteGetCompleteNode(e.visibleWrites, t);
    if (null != o) return o;
    e = compoundWriteChildCompoundWrite(e.visibleWrites, t);
    return compoundWriteIsEmpty(e)
        ? n
        : null != n || compoundWriteHasCompleteWrite(e, newEmptyPath())
        ? compoundWriteApply(e, n || ChildrenNode.EMPTY_NODE)
        : null;
}
function writeTreeCalcCompleteEventChildren(e, t, n) {
    let r = ChildrenNode.EMPTY_NODE;
    const i = compoundWriteGetCompleteNode(e.visibleWrites, t);
    if (i)
        return (
            i.isLeafNode() ||
                i.forEachChild(PRIORITY_INDEX, (e, t) => {
                    r = r.updateImmediateChild(e, t);
                }),
            r
        );
    if (n) {
        const o = compoundWriteChildCompoundWrite(e.visibleWrites, t);
        return (
            n.forEachChild(PRIORITY_INDEX, (e, t) => {
                t = compoundWriteApply(
                    compoundWriteChildCompoundWrite(o, new Path(e)),
                    t
                );
                r = r.updateImmediateChild(e, t);
            }),
            compoundWriteGetCompleteChildren(o).forEach((e) => {
                r = r.updateImmediateChild(e.name, e.node);
            }),
            r
        );
    }
    return (
        compoundWriteGetCompleteChildren(
            compoundWriteChildCompoundWrite(e.visibleWrites, t)
        ).forEach((e) => {
            r = r.updateImmediateChild(e.name, e.node);
        }),
        r
    );
}
function writeTreeCalcEventCacheAfterServerOverwrite(e, t, n, r, i) {
    assert(r || i, 'Either existingEventSnap or existingServerSnap must exist');
    t = pathChild(t, n);
    if (compoundWriteHasCompleteWrite(e.visibleWrites, t)) return null;
    t = compoundWriteChildCompoundWrite(e.visibleWrites, t);
    return compoundWriteIsEmpty(t)
        ? i.getChild(n)
        : compoundWriteApply(t, i.getChild(n));
}
function writeTreeCalcCompleteChild(e, t, n, r) {
    var i = pathChild(t, n),
        t = compoundWriteGetCompleteNode(e.visibleWrites, i);
    return null != t
        ? t
        : r.isCompleteForChild(n)
        ? compoundWriteApply(
              compoundWriteChildCompoundWrite(e.visibleWrites, i),
              r.getNode().getImmediateChild(n)
          )
        : null;
}
function writeTreeShadowingWrite(e, t) {
    return compoundWriteGetCompleteNode(e.visibleWrites, t);
}
function writeTreeCalcIndexedSlice(e, t, n, r, i, o, s) {
    let a;
    (e = compoundWriteChildCompoundWrite(e.visibleWrites, t)),
        (t = compoundWriteGetCompleteNode(e, newEmptyPath()));
    if (null != t) a = t;
    else {
        if (null == n) return [];
        a = compoundWriteApply(e, n);
    }
    if (((a = a.withIndex(s)), a.isEmpty() || a.isLeafNode())) return [];
    {
        const l = [],
            h = s.getCompare(),
            c = o ? a.getReverseIteratorFrom(r, s) : a.getIteratorFrom(r, s);
        let e = c.getNext();
        for (; e && l.length < i; )
            0 !== h(e, r) && l.push(e), (e = c.getNext());
        return l;
    }
}
function newWriteTree() {
    return {
        visibleWrites: CompoundWrite.empty(),
        allWrites: [],
        lastWriteId: -1,
    };
}
function writeTreeRefCalcCompleteEventCache(e, t, n, r) {
    return writeTreeCalcCompleteEventCache(e.writeTree, e.treePath, t, n, r);
}
function writeTreeRefCalcCompleteEventChildren(e, t) {
    return writeTreeCalcCompleteEventChildren(e.writeTree, e.treePath, t);
}
function writeTreeRefCalcEventCacheAfterServerOverwrite(e, t, n, r) {
    return writeTreeCalcEventCacheAfterServerOverwrite(
        e.writeTree,
        e.treePath,
        t,
        n,
        r
    );
}
function writeTreeRefShadowingWrite(e, t) {
    return writeTreeShadowingWrite(e.writeTree, pathChild(e.treePath, t));
}
function writeTreeRefCalcIndexedSlice(e, t, n, r, i, o) {
    return writeTreeCalcIndexedSlice(e.writeTree, e.treePath, t, n, r, i, o);
}
function writeTreeRefCalcCompleteChild(e, t, n) {
    return writeTreeCalcCompleteChild(e.writeTree, e.treePath, t, n);
}
function writeTreeRefChild(e, t) {
    return newWriteTreeRef(pathChild(e.treePath, t), e.writeTree);
}
function newWriteTreeRef(e, t) {
    return { treePath: e, writeTree: t };
}
class ChildChangeAccumulator {
    constructor() {
        this.changeMap = new Map();
    }
    trackChildChange(e) {
        var t = e.type,
            n = e.childName;
        assert(
            'child_added' === t ||
                'child_changed' === t ||
                'child_removed' === t,
            'Only child changes supported for tracking'
        ),
            assert(
                '.priority' !== n,
                'Only non-priority child changes can be tracked.'
            );
        var r = this.changeMap.get(n);
        if (r) {
            var i = r.type;
            if ('child_added' === t && 'child_removed' === i)
                this.changeMap.set(
                    n,
                    changeChildChanged(n, e.snapshotNode, r.snapshotNode)
                );
            else if ('child_removed' === t && 'child_added' === i)
                this.changeMap.delete(n);
            else if ('child_removed' === t && 'child_changed' === i)
                this.changeMap.set(n, changeChildRemoved(n, r.oldSnap));
            else if ('child_changed' === t && 'child_added' === i)
                this.changeMap.set(n, changeChildAdded(n, e.snapshotNode));
            else {
                if ('child_changed' !== t || 'child_changed' !== i)
                    throw assertionError(
                        'Illegal combination of changes: ' +
                            e +
                            ' occurred after ' +
                            r
                    );
                this.changeMap.set(
                    n,
                    changeChildChanged(n, e.snapshotNode, r.oldSnap)
                );
            }
        } else this.changeMap.set(n, e);
    }
    getChanges() {
        return Array.from(this.changeMap.values());
    }
}
class NoCompleteChildSource_ {
    getCompleteChild(e) {
        return null;
    }
    getChildAfterChild(e, t, n) {
        return null;
    }
}
const NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();
class WriteTreeCompleteChildSource {
    constructor(e, t, n = null) {
        (this.writes_ = e),
            (this.viewCache_ = t),
            (this.optCompleteServerCache_ = n);
    }
    getCompleteChild(e) {
        const t = this.viewCache_.eventCache;
        if (t.isCompleteForChild(e)) return t.getNode().getImmediateChild(e);
        var n =
            null != this.optCompleteServerCache_
                ? new CacheNode(this.optCompleteServerCache_, !0, !1)
                : this.viewCache_.serverCache;
        return writeTreeRefCalcCompleteChild(this.writes_, e, n);
    }
    getChildAfterChild(e, t, n) {
        var r =
                null != this.optCompleteServerCache_
                    ? this.optCompleteServerCache_
                    : viewCacheGetCompleteServerSnap(this.viewCache_),
            e = writeTreeRefCalcIndexedSlice(this.writes_, r, t, 1, n, e);
        return 0 === e.length ? null : e[0];
    }
}
function newViewProcessor(e) {
    return { filter: e };
}
function viewProcessorAssertIndexed(e, t) {
    assert(
        t.eventCache.getNode().isIndexed(e.filter.getIndex()),
        'Event snap not indexed'
    ),
        assert(
            t.serverCache.getNode().isIndexed(e.filter.getIndex()),
            'Server snap not indexed'
        );
}
function viewProcessorApplyOperation(e, t, n, r, i) {
    const o = new ChildChangeAccumulator();
    let s, a;
    if (n.type === OperationType.OVERWRITE) {
        var l = n;
        s = l.source.fromUser
            ? viewProcessorApplyUserOverwrite(e, t, l.path, l.snap, r, i, o)
            : (assert(l.source.fromServer, 'Unknown source.'),
              (a =
                  l.source.tagged ||
                  (t.serverCache.isFiltered() && !pathIsEmpty(l.path))),
              viewProcessorApplyServerOverwrite(
                  e,
                  t,
                  l.path,
                  l.snap,
                  r,
                  i,
                  a,
                  o
              ));
    } else if (n.type === OperationType.MERGE) {
        var h = n;
        s = h.source.fromUser
            ? viewProcessorApplyUserMerge(e, t, h.path, h.children, r, i, o)
            : (assert(h.source.fromServer, 'Unknown source.'),
              (a = h.source.tagged || t.serverCache.isFiltered()),
              viewProcessorApplyServerMerge(
                  e,
                  t,
                  h.path,
                  h.children,
                  r,
                  i,
                  a,
                  o
              ));
    } else if (n.type === OperationType.ACK_USER_WRITE) {
        h = n;
        s = h.revert
            ? viewProcessorRevertUserWrite(e, t, h.path, r, i, o)
            : viewProcessorAckUserWrite(e, t, h.path, h.affectedTree, r, i, o);
    } else {
        if (n.type !== OperationType.LISTEN_COMPLETE)
            throw assertionError('Unknown operation type: ' + n.type);
        s = viewProcessorListenComplete(e, t, n.path, r, o);
    }
    r = o.getChanges();
    return (
        viewProcessorMaybeAddValueEvent(t, s, r), { viewCache: s, changes: r }
    );
}
function viewProcessorMaybeAddValueEvent(e, t, n) {
    const r = t.eventCache;
    if (r.isFullyInitialized()) {
        var i = r.getNode().isLeafNode() || r.getNode().isEmpty();
        const o = viewCacheGetCompleteEventSnap(e);
        (0 < n.length ||
            !e.eventCache.isFullyInitialized() ||
            (i && !r.getNode().equals(o)) ||
            !r.getNode().getPriority().equals(o.getPriority())) &&
            n.push(changeValue(viewCacheGetCompleteEventSnap(t)));
    }
}
function viewProcessorGenerateEventCacheAfterServerEvent(r, i, o, s, a, l) {
    const h = i.eventCache;
    if (null != writeTreeRefShadowingWrite(s, o)) return i;
    {
        let t, n;
        if (pathIsEmpty(o)) {
            var e;
            assert(
                i.serverCache.isFullyInitialized(),
                'If change path is empty, we must have complete server data'
            ),
                (t = i.serverCache.isFiltered()
                    ? ((e = writeTreeRefCalcCompleteEventChildren(
                          s,
                          (e = viewCacheGetCompleteServerSnap(i)) instanceof
                              ChildrenNode
                              ? e
                              : ChildrenNode.EMPTY_NODE
                      )),
                      r.filter.updateFullNode(i.eventCache.getNode(), e, l))
                    : ((c = writeTreeRefCalcCompleteEventCache(
                          s,
                          viewCacheGetCompleteServerSnap(i)
                      )),
                      r.filter.updateFullNode(i.eventCache.getNode(), c, l)));
        } else {
            var c = pathGetFront(o);
            if ('.priority' === c) {
                assert(
                    1 === pathGetLength(o),
                    "Can't have a priority with additional path components"
                );
                var d = h.getNode();
                n = i.serverCache.getNode();
                var u = writeTreeRefCalcEventCacheAfterServerOverwrite(
                    s,
                    o,
                    d,
                    n
                );
                t = null != u ? r.filter.updatePriority(d, u) : h.getNode();
            } else {
                d = pathPopFront(o);
                let e;
                (e = h.isCompleteForChild(c)
                    ? ((n = i.serverCache.getNode()),
                      null !=
                      (u = writeTreeRefCalcEventCacheAfterServerOverwrite(
                          s,
                          o,
                          h.getNode(),
                          n
                      ))
                          ? h.getNode().getImmediateChild(c).updateChild(d, u)
                          : h.getNode().getImmediateChild(c))
                    : writeTreeRefCalcCompleteChild(s, c, i.serverCache)),
                    (t =
                        null != e
                            ? r.filter.updateChild(h.getNode(), c, e, d, a, l)
                            : h.getNode());
            }
        }
        return viewCacheUpdateEventSnap(
            i,
            t,
            h.isFullyInitialized() || pathIsEmpty(o),
            r.filter.filtersNodes()
        );
    }
}
function viewProcessorApplyServerOverwrite(e, t, n, r, i, o, s, a) {
    const l = t.serverCache;
    let h;
    const c = s ? e.filter : e.filter.getIndexedFilter();
    if (pathIsEmpty(n)) h = c.updateFullNode(l.getNode(), r, null);
    else if (c.filtersNodes() && !l.isFiltered()) {
        var d = l.getNode().updateChild(n, r);
        h = c.updateFullNode(l.getNode(), d, null);
    } else {
        s = pathGetFront(n);
        if (!l.isCompleteForPath(n) && 1 < pathGetLength(n)) return t;
        d = pathPopFront(n);
        const u = l.getNode().getImmediateChild(s);
        r = u.updateChild(d, r);
        h =
            '.priority' === s
                ? c.updatePriority(l.getNode(), r)
                : c.updateChild(
                      l.getNode(),
                      s,
                      r,
                      d,
                      NO_COMPLETE_CHILD_SOURCE,
                      null
                  );
    }
    t = viewCacheUpdateServerSnap(
        t,
        h,
        l.isFullyInitialized() || pathIsEmpty(n),
        c.filtersNodes()
    );
    return viewProcessorGenerateEventCacheAfterServerEvent(
        e,
        t,
        n,
        i,
        new WriteTreeCompleteChildSource(i, t, o),
        a
    );
}
function viewProcessorApplyUserOverwrite(t, n, r, i, e, o, s) {
    const a = n.eventCache;
    let l, h;
    const c = new WriteTreeCompleteChildSource(e, n, o);
    if (pathIsEmpty(r))
        (h = t.filter.updateFullNode(n.eventCache.getNode(), i, s)),
            (l = viewCacheUpdateEventSnap(n, h, !0, t.filter.filtersNodes()));
    else {
        o = pathGetFront(r);
        if ('.priority' === o)
            (h = t.filter.updatePriority(n.eventCache.getNode(), i)),
                (l = viewCacheUpdateEventSnap(
                    n,
                    h,
                    a.isFullyInitialized(),
                    a.isFiltered()
                ));
        else {
            r = pathPopFront(r);
            const d = a.getNode().getImmediateChild(o);
            let e;
            if (pathIsEmpty(r)) e = i;
            else {
                const u = c.getCompleteChild(o);
                e =
                    null != u
                        ? '.priority' === pathGetBack(r) &&
                          u.getChild(pathParent(r)).isEmpty()
                            ? u
                            : u.updateChild(r, i)
                        : ChildrenNode.EMPTY_NODE;
            }
            l = d.equals(e)
                ? n
                : viewCacheUpdateEventSnap(
                      n,
                      t.filter.updateChild(a.getNode(), o, e, r, c, s),
                      a.isFullyInitialized(),
                      t.filter.filtersNodes()
                  );
        }
    }
    return l;
}
function viewProcessorCacheHasChild(e, t) {
    return e.eventCache.isCompleteForChild(t);
}
function viewProcessorApplyUserMerge(n, r, i, e, o, s, a) {
    let l = r;
    return (
        e.foreach((e, t) => {
            e = pathChild(i, e);
            viewProcessorCacheHasChild(r, pathGetFront(e)) &&
                (l = viewProcessorApplyUserOverwrite(n, l, e, t, o, s, a));
        }),
        e.foreach((e, t) => {
            e = pathChild(i, e);
            viewProcessorCacheHasChild(r, pathGetFront(e)) ||
                (l = viewProcessorApplyUserOverwrite(n, l, e, t, o, s, a));
        }),
        l
    );
}
function viewProcessorApplyMerge(e, n, t) {
    return (
        t.foreach((e, t) => {
            n = n.updateChild(e, t);
        }),
        n
    );
}
function viewProcessorApplyServerMerge(r, i, e, t, o, s, a, l) {
    if (
        i.serverCache.getNode().isEmpty() &&
        !i.serverCache.isFullyInitialized()
    )
        return i;
    let h = i,
        n;
    n = pathIsEmpty(e) ? t : new ImmutableTree(null).setTree(e, t);
    const c = i.serverCache.getNode();
    return (
        n.children.inorderTraversal((e, t) => {
            var n;
            c.hasChild(e) &&
                ((n = i.serverCache.getNode().getImmediateChild(e)),
                (t = viewProcessorApplyMerge(r, n, t)),
                (h = viewProcessorApplyServerOverwrite(
                    r,
                    h,
                    new Path(e),
                    t,
                    o,
                    s,
                    a,
                    l
                )));
        }),
        n.children.inorderTraversal((e, t) => {
            var n = !i.serverCache.isCompleteForChild(e) && void 0 === t.value;
            c.hasChild(e) ||
                n ||
                ((n = i.serverCache.getNode().getImmediateChild(e)),
                (t = viewProcessorApplyMerge(r, n, t)),
                (h = viewProcessorApplyServerOverwrite(
                    r,
                    h,
                    new Path(e),
                    t,
                    o,
                    s,
                    a,
                    l
                )));
        }),
        h
    );
}
function viewProcessorAckUserWrite(e, t, i, n, o, s, a) {
    if (null != writeTreeRefShadowingWrite(o, i)) return t;
    var l = t.serverCache.isFiltered();
    const h = t.serverCache;
    if (null != n.value) {
        if (
            (pathIsEmpty(i) && h.isFullyInitialized()) ||
            h.isCompleteForPath(i)
        )
            return viewProcessorApplyServerOverwrite(
                e,
                t,
                i,
                h.getNode().getChild(i),
                o,
                s,
                l,
                a
            );
        if (pathIsEmpty(i)) {
            let n = new ImmutableTree(null);
            return (
                h.getNode().forEachChild(KEY_INDEX, (e, t) => {
                    n = n.set(new Path(e), t);
                }),
                viewProcessorApplyServerMerge(e, t, i, n, o, s, l, a)
            );
        }
        return t;
    }
    {
        let r = new ImmutableTree(null);
        return (
            n.foreach((e, t) => {
                var n = pathChild(i, e);
                h.isCompleteForPath(n) &&
                    (r = r.set(e, h.getNode().getChild(n)));
            }),
            viewProcessorApplyServerMerge(e, t, i, r, o, s, l, a)
        );
    }
}
function viewProcessorListenComplete(e, t, n, r, i) {
    const o = t.serverCache;
    return viewProcessorGenerateEventCacheAfterServerEvent(
        e,
        viewCacheUpdateServerSnap(
            t,
            o.getNode(),
            o.isFullyInitialized() || pathIsEmpty(n),
            o.isFiltered()
        ),
        n,
        r,
        NO_COMPLETE_CHILD_SOURCE,
        i
    );
}
function viewProcessorRevertUserWrite(n, r, i, o, s, a) {
    let l;
    if (null != writeTreeRefShadowingWrite(o, i)) return r;
    {
        s = new WriteTreeCompleteChildSource(o, r, s);
        const c = r.eventCache.getNode();
        let t;
        if (pathIsEmpty(i) || '.priority' === pathGetFront(i)) {
            let e;
            (e = r.serverCache.isFullyInitialized()
                ? writeTreeRefCalcCompleteEventCache(
                      o,
                      viewCacheGetCompleteServerSnap(r)
                  )
                : ((h = r.serverCache.getNode()),
                  assert(
                      h instanceof ChildrenNode,
                      'serverChildren would be complete if leaf node'
                  ),
                  writeTreeRefCalcCompleteEventChildren(o, h))),
                (e = e),
                (t = n.filter.updateFullNode(c, e, a));
        } else {
            var h = pathGetFront(i);
            let e = writeTreeRefCalcCompleteChild(o, h, r.serverCache);
            null == e &&
                r.serverCache.isCompleteForChild(h) &&
                (e = c.getImmediateChild(h)),
                (t =
                    null != e
                        ? n.filter.updateChild(c, h, e, pathPopFront(i), s, a)
                        : r.eventCache.getNode().hasChild(h)
                        ? n.filter.updateChild(
                              c,
                              h,
                              ChildrenNode.EMPTY_NODE,
                              pathPopFront(i),
                              s,
                              a
                          )
                        : c),
                t.isEmpty() &&
                    r.serverCache.isFullyInitialized() &&
                    ((l = writeTreeRefCalcCompleteEventCache(
                        o,
                        viewCacheGetCompleteServerSnap(r)
                    )),
                    l.isLeafNode() && (t = n.filter.updateFullNode(t, l, a)));
        }
        return (
            (l =
                r.serverCache.isFullyInitialized() ||
                null != writeTreeRefShadowingWrite(o, newEmptyPath())),
            viewCacheUpdateEventSnap(r, t, l, n.filter.filtersNodes())
        );
    }
}
class View {
    constructor(e, t) {
        (this.query_ = e), (this.eventRegistrations_ = []);
        const n = this.query_._queryParams,
            r = new IndexedFilter(n.getIndex()),
            i = queryParamsGetNodeFilter(n);
        this.processor_ = newViewProcessor(i);
        const o = t.serverCache,
            s = t.eventCache;
        (e = r.updateFullNode(ChildrenNode.EMPTY_NODE, o.getNode(), null)),
            (t = i.updateFullNode(ChildrenNode.EMPTY_NODE, s.getNode(), null)),
            (e = new CacheNode(e, o.isFullyInitialized(), r.filtersNodes())),
            (t = new CacheNode(t, s.isFullyInitialized(), i.filtersNodes()));
        (this.viewCache_ = newViewCache(t, e)),
            (this.eventGenerator_ = new EventGenerator(this.query_));
    }
    get query() {
        return this.query_;
    }
}
function viewGetServerCache(e) {
    return e.viewCache_.serverCache.getNode();
}
function viewGetCompleteNode(e) {
    return viewCacheGetCompleteEventSnap(e.viewCache_);
}
function viewGetCompleteServerCache(e, t) {
    const n = viewCacheGetCompleteServerSnap(e.viewCache_);
    return n &&
        (e.query._queryParams.loadsAllData() ||
            (!pathIsEmpty(t) &&
                !n.getImmediateChild(pathGetFront(t)).isEmpty()))
        ? n.getChild(t)
        : null;
}
function viewIsEmpty(e) {
    return 0 === e.eventRegistrations_.length;
}
function viewAddEventRegistration(e, t) {
    e.eventRegistrations_.push(t);
}
function viewRemoveEventRegistration(n, r, t) {
    const i = [];
    if (t) {
        assert(null == r, 'A cancel should cancel all event registrations.');
        const o = n.query._path;
        n.eventRegistrations_.forEach((e) => {
            e = e.createCancelEvent(t, o);
            e && i.push(e);
        });
    }
    if (r) {
        let t = [];
        for (let e = 0; e < n.eventRegistrations_.length; ++e) {
            const s = n.eventRegistrations_[e];
            if (s.matches(r)) {
                if (r.hasAnyCallback()) {
                    t = t.concat(n.eventRegistrations_.slice(e + 1));
                    break;
                }
            } else t.push(s);
        }
        n.eventRegistrations_ = t;
    } else n.eventRegistrations_ = [];
    return i;
}
function viewApplyOperation(e, t, n, r) {
    t.type === OperationType.MERGE &&
        null !== t.source.queryId &&
        (assert(
            viewCacheGetCompleteServerSnap(e.viewCache_),
            'We should always have a full cache before handling merges'
        ),
        assert(
            viewCacheGetCompleteEventSnap(e.viewCache_),
            'Missing event cache, even though we have a server cache'
        ));
    const i = e.viewCache_,
        o = viewProcessorApplyOperation(e.processor_, i, t, n, r);
    return (
        viewProcessorAssertIndexed(e.processor_, o.viewCache),
        assert(
            o.viewCache.serverCache.isFullyInitialized() ||
                !i.serverCache.isFullyInitialized(),
            'Once a server snap is complete, it should never go back'
        ),
        (e.viewCache_ = o.viewCache),
        viewGenerateEventsForChanges_(
            e,
            o.changes,
            o.viewCache.eventCache.getNode(),
            null
        )
    );
}
function viewGetInitialEvents(e, t) {
    const n = e.viewCache_.eventCache,
        r = [];
    if (!n.getNode().isLeafNode()) {
        const i = n.getNode();
        i.forEachChild(PRIORITY_INDEX, (e, t) => {
            r.push(changeChildAdded(e, t));
        });
    }
    return (
        n.isFullyInitialized() && r.push(changeValue(n.getNode())),
        viewGenerateEventsForChanges_(e, r, n.getNode(), t)
    );
}
function viewGenerateEventsForChanges_(e, t, n, r) {
    r = r ? [r] : e.eventRegistrations_;
    return eventGeneratorGenerateEventsForChanges(e.eventGenerator_, t, n, r);
}
let referenceConstructor$1;
class SyncPoint {
    constructor() {
        this.views = new Map();
    }
}
function syncPointSetReferenceConstructor(e) {
    assert(
        !referenceConstructor$1,
        '__referenceConstructor has already been defined'
    ),
        (referenceConstructor$1 = e);
}
function syncPointGetReferenceConstructor() {
    return (
        assert(referenceConstructor$1, 'Reference.ts has not been loaded'),
        referenceConstructor$1
    );
}
function syncPointIsEmpty(e) {
    return 0 === e.views.size;
}
function syncPointApplyOperation(t, n, r, i) {
    var e = n.source.queryId;
    if (null !== e) {
        e = t.views.get(e);
        return (
            assert(null != e, 'SyncTree gave us an op for an invalid query.'),
            viewApplyOperation(e, n, r, i)
        );
    }
    {
        let e = [];
        for (const o of t.views.values())
            e = e.concat(viewApplyOperation(o, n, r, i));
        return e;
    }
}
function syncPointGetView(e, n, r, i, o) {
    var t = n._queryIdentifier,
        t = e.views.get(t);
    if (t) return t;
    {
        let e = writeTreeRefCalcCompleteEventCache(r, o ? i : null),
            t = !1;
        t =
            !!e ||
            ((e =
                i instanceof ChildrenNode
                    ? writeTreeRefCalcCompleteEventChildren(r, i)
                    : ChildrenNode.EMPTY_NODE),
            !1);
        o = newViewCache(new CacheNode(e, t, !1), new CacheNode(i, o, !1));
        return new View(n, o);
    }
}
function syncPointAddEventRegistration(e, t, n, r, i, o) {
    o = syncPointGetView(e, t, r, i, o);
    return (
        e.views.has(t._queryIdentifier) || e.views.set(t._queryIdentifier, o),
        viewAddEventRegistration(o, n),
        viewGetInitialEvents(o, n)
    );
}
function syncPointRemoveEventRegistration(e, t, n, r) {
    var i = t._queryIdentifier;
    const o = [];
    let s = [];
    var a = syncPointHasCompleteView(e);
    if ('default' === i)
        for (var [l, h] of e.views.entries())
            (s = s.concat(viewRemoveEventRegistration(h, n, r))),
                viewIsEmpty(h) &&
                    (e.views.delete(l),
                    h.query._queryParams.loadsAllData() || o.push(h.query));
    else {
        const c = e.views.get(i);
        c &&
            ((s = s.concat(viewRemoveEventRegistration(c, n, r))),
            viewIsEmpty(c) &&
                (e.views.delete(i),
                c.query._queryParams.loadsAllData() || o.push(c.query)));
    }
    return (
        a &&
            !syncPointHasCompleteView(e) &&
            o.push(new (syncPointGetReferenceConstructor())(t._repo, t._path)),
        { removed: o, events: s }
    );
}
function syncPointGetQueryViews(e) {
    const t = [];
    for (const n of e.views.values())
        n.query._queryParams.loadsAllData() || t.push(n);
    return t;
}
function syncPointGetCompleteServerCache(e, t) {
    let n = null;
    for (const r of e.views.values()) n = n || viewGetCompleteServerCache(r, t);
    return n;
}
function syncPointViewForQuery(e, t) {
    const n = t._queryParams;
    if (n.loadsAllData()) return syncPointGetCompleteView(e);
    t = t._queryIdentifier;
    return e.views.get(t);
}
function syncPointViewExistsForQuery(e, t) {
    return null != syncPointViewForQuery(e, t);
}
function syncPointHasCompleteView(e) {
    return null != syncPointGetCompleteView(e);
}
function syncPointGetCompleteView(e) {
    for (const t of e.views.values())
        if (t.query._queryParams.loadsAllData()) return t;
    return null;
}
let referenceConstructor;
function syncTreeSetReferenceConstructor(e) {
    assert(
        !referenceConstructor,
        '__referenceConstructor has already been defined'
    ),
        (referenceConstructor = e);
}
function syncTreeGetReferenceConstructor() {
    return (
        assert(referenceConstructor, 'Reference.ts has not been loaded'),
        referenceConstructor
    );
}
let syncTreeNextQueryTag_ = 1;
class SyncTree {
    constructor(e) {
        (this.listenProvider_ = e),
            (this.syncPointTree_ = new ImmutableTree(null)),
            (this.pendingWriteTree_ = newWriteTree()),
            (this.tagToQueryMap = new Map()),
            (this.queryToTagMap = new Map());
    }
}
function syncTreeApplyUserOverwrite(e, t, n, r, i) {
    return (
        writeTreeAddOverwrite(e.pendingWriteTree_, t, n, r, i),
        i
            ? syncTreeApplyOperationToSyncPoints_(
                  e,
                  new Overwrite(newOperationSourceUser(), t, n)
              )
            : []
    );
}
function syncTreeApplyUserMerge(e, t, n, r) {
    writeTreeAddMerge(e.pendingWriteTree_, t, n, r);
    n = ImmutableTree.fromObject(n);
    return syncTreeApplyOperationToSyncPoints_(
        e,
        new Merge(newOperationSourceUser(), t, n)
    );
}
function syncTreeAckUserWrite(e, t, n = !1) {
    var r = writeTreeGetWrite(e.pendingWriteTree_, t);
    if (writeTreeRemoveWrite(e.pendingWriteTree_, t)) {
        let t = new ImmutableTree(null);
        return (
            null != r.snap
                ? (t = t.set(newEmptyPath(), !0))
                : each(r.children, (e) => {
                      t = t.set(new Path(e), !0);
                  }),
            syncTreeApplyOperationToSyncPoints_(
                e,
                new AckUserWrite(r.path, t, n)
            )
        );
    }
    return [];
}
function syncTreeApplyServerOverwrite(e, t, n) {
    return syncTreeApplyOperationToSyncPoints_(
        e,
        new Overwrite(newOperationSourceServer(), t, n)
    );
}
function syncTreeApplyServerMerge(e, t, n) {
    n = ImmutableTree.fromObject(n);
    return syncTreeApplyOperationToSyncPoints_(
        e,
        new Merge(newOperationSourceServer(), t, n)
    );
}
function syncTreeApplyListenComplete(e, t) {
    return syncTreeApplyOperationToSyncPoints_(
        e,
        new ListenComplete(newOperationSourceServer(), t)
    );
}
function syncTreeApplyTaggedListenComplete(e, t, n) {
    var r = syncTreeQueryKeyForTag_(e, n);
    if (r) {
        (n = syncTreeParseQueryKey_(r)),
            (r = n.path),
            (n = n.queryId),
            (t = newRelativePath(r, t));
        return syncTreeApplyTaggedOperation_(
            e,
            r,
            new ListenComplete(newOperationSourceServerTaggedQuery(n), t)
        );
    }
    return [];
}
function syncTreeRemoveEventRegistration(n, e, t, r) {
    var i = e._path,
        o = n.syncPointTree_.get(i);
    let s = [];
    if (
        o &&
        ('default' === e._queryIdentifier || syncPointViewExistsForQuery(o, e))
    ) {
        t = syncPointRemoveEventRegistration(o, e, t, r);
        syncPointIsEmpty(o) && (n.syncPointTree_ = n.syncPointTree_.remove(i));
        const c = t.removed;
        s = t.events;
        (o = -1 !== c.findIndex((e) => e._queryParams.loadsAllData())),
            (t = n.syncPointTree_.findOnPath(i, (e, t) =>
                syncPointHasCompleteView(t)
            ));
        if (o && !t) {
            const d = n.syncPointTree_.subtree(i);
            if (!d.isEmpty()) {
                var a = syncTreeCollectDistinctViewsForSubTree_(d);
                for (let e = 0; e < a.length; ++e) {
                    var l = a[e],
                        h = l.query,
                        l = syncTreeCreateListenerForView_(n, l);
                    n.listenProvider_.startListening(
                        syncTreeQueryForListening_(h),
                        syncTreeTagForQuery_(n, h),
                        l.hashFn,
                        l.onComplete
                    );
                }
            }
        }
        !t &&
            0 < c.length &&
            !r &&
            (o
                ? n.listenProvider_.stopListening(
                      syncTreeQueryForListening_(e),
                      null
                  )
                : c.forEach((e) => {
                      var t = n.queryToTagMap.get(syncTreeMakeQueryKey_(e));
                      n.listenProvider_.stopListening(
                          syncTreeQueryForListening_(e),
                          t
                      );
                  })),
            syncTreeRemoveTags_(n, c);
    }
    return s;
}
function syncTreeApplyTaggedQueryOverwrite(e, t, n, r) {
    var i = syncTreeQueryKeyForTag_(e, r);
    if (null == i) return [];
    (r = syncTreeParseQueryKey_(i)),
        (i = r.path),
        (r = r.queryId),
        (t = newRelativePath(i, t));
    return syncTreeApplyTaggedOperation_(
        e,
        i,
        new Overwrite(newOperationSourceServerTaggedQuery(r), t, n)
    );
}
function syncTreeApplyTaggedQueryMerge(e, t, n, r) {
    var i = syncTreeQueryKeyForTag_(e, r);
    if (i) {
        (r = syncTreeParseQueryKey_(i)),
            (i = r.path),
            (r = r.queryId),
            (t = newRelativePath(i, t)),
            (n = ImmutableTree.fromObject(n));
        return syncTreeApplyTaggedOperation_(
            e,
            i,
            new Merge(newOperationSourceServerTaggedQuery(r), t, n)
        );
    }
    return [];
}
function syncTreeAddEventRegistration(e, t, n) {
    const r = t._path;
    let i = null,
        o = !1;
    e.syncPointTree_.foreachOnPath(r, (e, t) => {
        e = newRelativePath(e, r);
        (i = i || syncPointGetCompleteServerCache(t, e)),
            (o = o || syncPointHasCompleteView(t));
    });
    let s = e.syncPointTree_.get(r);
    s
        ? ((o = o || syncPointHasCompleteView(s)),
          (i = i || syncPointGetCompleteServerCache(s, newEmptyPath())))
        : ((s = new SyncPoint()),
          (e.syncPointTree_ = e.syncPointTree_.set(r, s)));
    let a;
    if (null != i) a = !0;
    else {
        (a = !1), (i = ChildrenNode.EMPTY_NODE);
        const u = e.syncPointTree_.subtree(r);
        u.foreachChild((e, t) => {
            t = syncPointGetCompleteServerCache(t, newEmptyPath());
            t && (i = i.updateImmediateChild(e, t));
        });
    }
    var l,
        h = syncPointViewExistsForQuery(s, t);
    h ||
        t._queryParams.loadsAllData() ||
        ((c = syncTreeMakeQueryKey_(t)),
        assert(
            !e.queryToTagMap.has(c),
            'View does not exist, but we have a tag'
        ),
        (l = syncTreeGetNextQueryTag_()),
        e.queryToTagMap.set(c, l),
        e.tagToQueryMap.set(l, c));
    var c = writeTreeChildWrites(e.pendingWriteTree_, r);
    let d = syncPointAddEventRegistration(s, t, n, c, i, a);
    return (
        h ||
            o ||
            ((h = syncPointViewForQuery(s, t)),
            (d = d.concat(syncTreeSetupListener_(e, t, h)))),
        d
    );
}
function syncTreeCalcCompleteEventCache(e, n, t) {
    var r = e.pendingWriteTree_,
        e = e.syncPointTree_.findOnPath(n, (e, t) => {
            e = syncPointGetCompleteServerCache(t, newRelativePath(e, n));
            if (e) return e;
        });
    return writeTreeCalcCompleteEventCache(r, n, e, t, !0);
}
function syncTreeGetServerValue(e, t) {
    const n = t._path;
    let r = null;
    e.syncPointTree_.foreachOnPath(n, (e, t) => {
        e = newRelativePath(e, n);
        r = r || syncPointGetCompleteServerCache(t, e);
    });
    let i = e.syncPointTree_.get(n);
    i
        ? (r = r || syncPointGetCompleteServerCache(i, newEmptyPath()))
        : ((i = new SyncPoint()),
          (e.syncPointTree_ = e.syncPointTree_.set(n, i)));
    var o = null != r;
    const s = o ? new CacheNode(r, !0, !1) : null;
    e = writeTreeChildWrites(e.pendingWriteTree_, t._path);
    return viewGetCompleteNode(
        syncPointGetView(i, t, e, o ? s.getNode() : ChildrenNode.EMPTY_NODE, o)
    );
}
function syncTreeApplyOperationToSyncPoints_(e, t) {
    return syncTreeApplyOperationHelper_(
        t,
        e.syncPointTree_,
        null,
        writeTreeChildWrites(e.pendingWriteTree_, newEmptyPath())
    );
}
function syncTreeApplyOperationHelper_(t, n, r, i) {
    if (pathIsEmpty(t.path))
        return syncTreeApplyOperationDescendantsHelper_(t, n, r, i);
    {
        var o = n.get(newEmptyPath());
        null == r &&
            null != o &&
            (r = syncPointGetCompleteServerCache(o, newEmptyPath()));
        let e = [];
        var s = pathGetFront(t.path),
            a = t.operationForChild(s),
            l = n.children.get(s);
        return (
            l &&
                a &&
                ((n = r ? r.getImmediateChild(s) : null),
                (s = writeTreeRefChild(i, s)),
                (e = e.concat(syncTreeApplyOperationHelper_(a, l, n, s)))),
            o && (e = e.concat(syncPointApplyOperation(o, t, i, r))),
            e
        );
    }
}
function syncTreeApplyOperationDescendantsHelper_(i, e, o, s) {
    var t = e.get(newEmptyPath());
    null == o &&
        null != t &&
        (o = syncPointGetCompleteServerCache(t, newEmptyPath()));
    let a = [];
    return (
        e.children.inorderTraversal((e, t) => {
            var n = o ? o.getImmediateChild(e) : null,
                r = writeTreeRefChild(s, e),
                e = i.operationForChild(e);
            e &&
                (a = a.concat(
                    syncTreeApplyOperationDescendantsHelper_(e, t, n, r)
                ));
        }),
        t && (a = a.concat(syncPointApplyOperation(t, i, s, o))),
        a
    );
}
function syncTreeCreateListenerForView_(t, n) {
    const r = n.query,
        i = syncTreeTagForQuery_(t, r);
    return {
        hashFn: () => {
            const e = viewGetServerCache(n) || ChildrenNode.EMPTY_NODE;
            return e.hash();
        },
        onComplete: (e) => {
            if ('ok' === e)
                return i
                    ? syncTreeApplyTaggedListenComplete(t, r._path, i)
                    : syncTreeApplyListenComplete(t, r._path);
            e = errorForServerCode(e, r);
            return syncTreeRemoveEventRegistration(t, r, null, e);
        },
    };
}
function syncTreeTagForQuery_(e, t) {
    t = syncTreeMakeQueryKey_(t);
    return e.queryToTagMap.get(t);
}
function syncTreeMakeQueryKey_(e) {
    return e._path.toString() + '$' + e._queryIdentifier;
}
function syncTreeQueryKeyForTag_(e, t) {
    return e.tagToQueryMap.get(t);
}
function syncTreeParseQueryKey_(e) {
    var t = e.indexOf('$');
    return (
        assert(-1 !== t && t < e.length - 1, 'Bad queryKey.'),
        { queryId: e.substr(t + 1), path: new Path(e.substr(0, t)) }
    );
}
function syncTreeApplyTaggedOperation_(e, t, n) {
    var r = e.syncPointTree_.get(t);
    return (
        assert(r, "Missing sync point for query tag that we're tracking"),
        syncPointApplyOperation(
            r,
            n,
            writeTreeChildWrites(e.pendingWriteTree_, t),
            null
        )
    );
}
function syncTreeCollectDistinctViewsForSubTree_(e) {
    return e.fold((e, t, r) => {
        if (t && syncPointHasCompleteView(t))
            return [syncPointGetCompleteView(t)];
        {
            let n = [];
            return (
                t && (n = syncPointGetQueryViews(t)),
                each(r, (e, t) => {
                    n = n.concat(t);
                }),
                n
            );
        }
    });
}
function syncTreeQueryForListening_(e) {
    return e._queryParams.loadsAllData() && !e._queryParams.isDefault()
        ? new (syncTreeGetReferenceConstructor())(e._repo, e._path)
        : e;
}
function syncTreeRemoveTags_(t, n) {
    for (let e = 0; e < n.length; ++e) {
        const o = n[e];
        var r, i;
        o._queryParams.loadsAllData() ||
            ((r = syncTreeMakeQueryKey_(o)),
            (i = t.queryToTagMap.get(r)),
            t.queryToTagMap.delete(r),
            t.tagToQueryMap.delete(i));
    }
}
function syncTreeGetNextQueryTag_() {
    return syncTreeNextQueryTag_++;
}
function syncTreeSetupListener_(t, e, n) {
    var r = e._path,
        i = syncTreeTagForQuery_(t, e),
        n = syncTreeCreateListenerForView_(t, n),
        n = t.listenProvider_.startListening(
            syncTreeQueryForListening_(e),
            i,
            n.hashFn,
            n.onComplete
        );
    const o = t.syncPointTree_.subtree(r);
    if (i)
        assert(
            !syncPointHasCompleteView(o.value),
            "If we're adding a query, it shouldn't be shadowed"
        );
    else {
        var s = o.fold((e, t, r) => {
            if (!pathIsEmpty(e) && t && syncPointHasCompleteView(t))
                return [syncPointGetCompleteView(t).query];
            {
                let n = [];
                return (
                    t &&
                        (n = n.concat(
                            syncPointGetQueryViews(t).map((e) => e.query)
                        )),
                    each(r, (e, t) => {
                        n = n.concat(t);
                    }),
                    n
                );
            }
        });
        for (let e = 0; e < s.length; ++e) {
            var a = s[e];
            t.listenProvider_.stopListening(
                syncTreeQueryForListening_(a),
                syncTreeTagForQuery_(t, a)
            );
        }
    }
    return n;
}
class ExistingValueProvider {
    constructor(e) {
        this.node_ = e;
    }
    getImmediateChild(e) {
        e = this.node_.getImmediateChild(e);
        return new ExistingValueProvider(e);
    }
    node() {
        return this.node_;
    }
}
class DeferredValueProvider {
    constructor(e, t) {
        (this.syncTree_ = e), (this.path_ = t);
    }
    getImmediateChild(e) {
        e = pathChild(this.path_, e);
        return new DeferredValueProvider(this.syncTree_, e);
    }
    node() {
        return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);
    }
}
const generateWithValues = function (e) {
        return (
            ((e = e || {}).timestamp = e.timestamp || new Date().getTime()), e
        );
    },
    resolveDeferredLeafValue = function (e, t, n) {
        return e && 'object' == typeof e
            ? (assert('.sv' in e, 'Unexpected leaf node or priority contents'),
              'string' == typeof e['.sv']
                  ? resolveScalarDeferredValue(e['.sv'], t, n)
                  : 'object' == typeof e['.sv']
                  ? resolveComplexDeferredValue(e['.sv'], t)
                  : void assert(
                        !1,
                        'Unexpected server value: ' + JSON.stringify(e, null, 2)
                    ))
            : e;
    },
    resolveScalarDeferredValue = function (e, t, n) {
        if ('timestamp' === e) return n.timestamp;
        assert(!1, 'Unexpected server value: ' + e);
    },
    resolveComplexDeferredValue = function (e, t, n) {
        e.hasOwnProperty('increment') ||
            assert(
                !1,
                'Unexpected server value: ' + JSON.stringify(e, null, 2)
            );
        e = e.increment;
        'number' != typeof e && assert(!1, 'Unexpected increment value: ' + e);
        const r = t.node();
        if (
            (assert(
                null !== r && void 0 !== r,
                'Expected ChildrenNode.EMPTY_NODE for nulls'
            ),
            !r.isLeafNode())
        )
            return e;
        const i = r;
        t = i.getValue();
        return 'number' != typeof t ? e : t + e;
    },
    resolveDeferredValueTree = function (e, t, n, r) {
        return resolveDeferredValue(t, new DeferredValueProvider(n, e), r);
    },
    resolveDeferredValueSnapshot = function (e, t, n) {
        return resolveDeferredValue(e, new ExistingValueProvider(t), n);
    };
function resolveDeferredValue(e, r, i) {
    var t = e.getPriority().val(),
        n = resolveDeferredLeafValue(t, r.getImmediateChild('.priority'), i);
    let o;
    if (e.isLeafNode()) {
        const s = e;
        t = resolveDeferredLeafValue(s.getValue(), r, i);
        return t !== s.getValue() || n !== s.getPriority().val()
            ? new LeafNode(t, nodeFromJSON(n))
            : e;
    }
    {
        const a = e;
        return (
            (o = a),
            n !== a.getPriority().val() &&
                (o = o.updatePriority(new LeafNode(n))),
            a.forEachChild(PRIORITY_INDEX, (e, t) => {
                var n = resolveDeferredValue(t, r.getImmediateChild(e), i);
                n !== t && (o = o.updateImmediateChild(e, n));
            }),
            o
        );
    }
}
class Tree {
    constructor(e = '', t = null, n = { children: {}, childCount: 0 }) {
        (this.name = e), (this.parent = t), (this.node = n);
    }
}
function treeSubTree(e, t) {
    let n = t instanceof Path ? t : new Path(t),
        r = e,
        i = pathGetFront(n);
    for (; null !== i; ) {
        var o = safeGet(r.node.children, i) || { children: {}, childCount: 0 };
        (r = new Tree(i, r, o)), (n = pathPopFront(n)), (i = pathGetFront(n));
    }
    return r;
}
function treeGetValue(e) {
    return e.node.value;
}
function treeSetValue(e, t) {
    (e.node.value = t), treeUpdateParents(e);
}
function treeHasChildren(e) {
    return 0 < e.node.childCount;
}
function treeIsEmpty(e) {
    return void 0 === treeGetValue(e) && !treeHasChildren(e);
}
function treeForEachChild(n, r) {
    each(n.node.children, (e, t) => {
        r(new Tree(e, n, t));
    });
}
function treeForEachDescendant(e, t, n, r) {
    n && !r && t(e),
        treeForEachChild(e, (e) => {
            treeForEachDescendant(e, t, !0, r);
        }),
        n && r && t(e);
}
function treeForEachAncestor(e, t, n) {
    let r = n ? e : e.parent;
    for (; null !== r; ) {
        if (t(r)) return !0;
        r = r.parent;
    }
    return !1;
}
function treeGetPath(e) {
    return new Path(
        null === e.parent ? e.name : treeGetPath(e.parent) + '/' + e.name
    );
}
function treeUpdateParents(e) {
    null !== e.parent && treeUpdateChild(e.parent, e.name, e);
}
function treeUpdateChild(e, t, n) {
    var r = treeIsEmpty(n),
        i = contains(e.node.children, t);
    r && i
        ? (delete e.node.children[t], e.node.childCount--, treeUpdateParents(e))
        : r ||
          i ||
          ((e.node.children[t] = n.node),
          e.node.childCount++,
          treeUpdateParents(e));
}
const INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/,
    INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/,
    MAX_LEAF_SIZE_ = 10485760,
    isValidKey = function (e) {
        return (
            'string' == typeof e &&
            0 !== e.length &&
            !INVALID_KEY_REGEX_.test(e)
        );
    },
    isValidPathString = function (e) {
        return (
            'string' == typeof e &&
            0 !== e.length &&
            !INVALID_PATH_REGEX_.test(e)
        );
    },
    isValidRootPathString = function (e) {
        return (
            (e = e && e.replace(/^\/*\.info(\/|$)/, '/')), isValidPathString(e)
        );
    },
    isValidPriority = function (e) {
        return (
            null === e ||
            'string' == typeof e ||
            ('number' == typeof e && !isInvalidJSONNumber(e)) ||
            (e && 'object' == typeof e && contains(e, '.sv'))
        );
    },
    validateFirebaseDataArg = function (e, t, n, r) {
        (r && void 0 === t) ||
            validateFirebaseData(errorPrefix(e, 'value'), t, n);
    },
    validateFirebaseData = function (i, e, t) {
        const o = t instanceof Path ? new ValidationPath(t, i) : t;
        if (void 0 === e)
            throw new Error(
                i + 'contains undefined ' + validationPathToErrorString(o)
            );
        if ('function' == typeof e)
            throw new Error(
                i +
                    'contains a function ' +
                    validationPathToErrorString(o) +
                    ' with contents = ' +
                    e.toString()
            );
        if (isInvalidJSONNumber(e))
            throw new Error(
                i +
                    'contains ' +
                    e.toString() +
                    ' ' +
                    validationPathToErrorString(o)
            );
        if (
            'string' == typeof e &&
            e.length > MAX_LEAF_SIZE_ / 3 &&
            stringLength(e) > MAX_LEAF_SIZE_
        )
            throw new Error(
                i +
                    'contains a string greater than ' +
                    MAX_LEAF_SIZE_ +
                    ' utf8 bytes ' +
                    validationPathToErrorString(o) +
                    " ('" +
                    e.substring(0, 50) +
                    "...')"
            );
        if (e && 'object' == typeof e) {
            let n = !1,
                r = !1;
            if (
                (each(e, (e, t) => {
                    if ('.value' === e) n = !0;
                    else if (
                        '.priority' !== e &&
                        '.sv' !== e &&
                        ((r = !0), !isValidKey(e))
                    )
                        throw new Error(
                            i +
                                ' contains an invalid key (' +
                                e +
                                ') ' +
                                validationPathToErrorString(o) +
                                '.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"'
                        );
                    validationPathPush(o, e),
                        validateFirebaseData(i, t, o),
                        validationPathPop(o);
                }),
                n && r)
            )
                throw new Error(
                    i +
                        ' contains ".value" child ' +
                        validationPathToErrorString(o) +
                        ' in addition to actual children.'
                );
        }
    },
    validateFirebaseMergePaths = function (t, e) {
        let n, r;
        for (n = 0; n < e.length; n++) {
            r = e[n];
            var i = pathSlice(r);
            for (let e = 0; e < i.length; e++)
                if (
                    ('.priority' !== i[e] || e !== i.length - 1) &&
                    !isValidKey(i[e])
                )
                    throw new Error(
                        t +
                            'contains an invalid key (' +
                            i[e] +
                            ') in path ' +
                            r.toString() +
                            '. Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"'
                    );
        }
        e.sort(pathCompare);
        let o = null;
        for (n = 0; n < e.length; n++) {
            if (((r = e[n]), null !== o && pathContains(o, r)))
                throw new Error(
                    t +
                        'contains a path ' +
                        o.toString() +
                        ' that is ancestor of another path ' +
                        r.toString()
                );
            o = r;
        }
    },
    validateFirebaseMergeDataArg = function (e, t, r, n) {
        if (!n || void 0 !== t) {
            const i = errorPrefix(e, 'values');
            if (!t || 'object' != typeof t || Array.isArray(t))
                throw new Error(
                    i + ' must be an object containing the children to replace.'
                );
            const o = [];
            each(t, (e, t) => {
                const n = new Path(e);
                if (
                    (validateFirebaseData(i, t, pathChild(r, n)),
                    '.priority' === pathGetBack(n) && !isValidPriority(t))
                )
                    throw new Error(
                        i +
                            "contains an invalid value for '" +
                            n.toString() +
                            "', which must be a valid Firebase priority (a string, finite number, server value, or null)."
                    );
                o.push(n);
            }),
                validateFirebaseMergePaths(i, o);
        }
    },
    validatePriority = function (e, t, n) {
        if (!n || void 0 !== t) {
            if (isInvalidJSONNumber(t))
                throw new Error(
                    errorPrefix(e, 'priority') +
                        'is ' +
                        t.toString() +
                        ', but must be a valid Firebase priority (a string, finite number, server value, or null).'
                );
            if (!isValidPriority(t))
                throw new Error(
                    errorPrefix(e, 'priority') +
                        'must be a valid Firebase priority (a string, finite number, server value, or null).'
                );
        }
    },
    validateKey = function (e, t, n, r) {
        if (!((r && void 0 === n) || isValidKey(n)))
            throw new Error(
                errorPrefix(e, t) +
                    'was an invalid key = "' +
                    n +
                    '".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").'
            );
    },
    validatePathString = function (e, t, n, r) {
        if (!((r && void 0 === n) || isValidPathString(n)))
            throw new Error(
                errorPrefix(e, t) +
                    'was an invalid path = "' +
                    n +
                    '". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"'
            );
    },
    validateRootPathString = function (e, t, n, r) {
        (n = n && n.replace(/^\/*\.info(\/|$)/, '/')),
            validatePathString(e, t, n, r);
    },
    validateWritablePath = function (e, t) {
        if ('.info' === pathGetFront(t))
            throw new Error(e + " failed = Can't modify data under /.info/");
    },
    validateUrl = function (e, t) {
        var n = t.path.toString();
        if (
            'string' != typeof t.repoInfo.host ||
            0 === t.repoInfo.host.length ||
            (!isValidKey(t.repoInfo.namespace) &&
                'localhost' !== t.repoInfo.host.split(':')[0]) ||
            (0 !== n.length && !isValidRootPathString(n))
        )
            throw new Error(
                errorPrefix(e, 'url') +
                    'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".'
            );
    };
class EventQueue {
    constructor() {
        (this.eventLists_ = []), (this.recursionDepth_ = 0);
    }
}
function eventQueueQueueEvents(t, n) {
    let r = null;
    for (let e = 0; e < n.length; e++) {
        const o = n[e];
        var i = o.getPath();
        null === r ||
            pathEquals(i, r.path) ||
            (t.eventLists_.push(r), (r = null)),
            null === r && (r = { events: [], path: i }),
            r.events.push(o);
    }
    r && t.eventLists_.push(r);
}
function eventQueueRaiseEventsAtPath(e, t, n) {
    eventQueueQueueEvents(e, n),
        eventQueueRaiseQueuedEventsMatchingPredicate(e, (e) =>
            pathEquals(e, t)
        );
}
function eventQueueRaiseEventsForChangedPath(e, t, n) {
    eventQueueQueueEvents(e, n),
        eventQueueRaiseQueuedEventsMatchingPredicate(
            e,
            (e) => pathContains(e, t) || pathContains(t, e)
        );
}
function eventQueueRaiseQueuedEventsMatchingPredicate(t, n) {
    t.recursionDepth_++;
    let r = !0;
    for (let e = 0; e < t.eventLists_.length; e++) {
        var i = t.eventLists_[e];
        i &&
            (n(i.path)
                ? (eventListRaise(t.eventLists_[e]), (t.eventLists_[e] = null))
                : (r = !1));
    }
    r && (t.eventLists_ = []), t.recursionDepth_--;
}
function eventListRaise(t) {
    for (let e = 0; e < t.events.length; e++) {
        const r = t.events[e];
        var n;
        null !== r &&
            ((t.events[e] = null),
            (n = r.getEventRunner()),
            logger && log('event: ' + r.toString()),
            exceptionGuard(n));
    }
}
const INTERRUPT_REASON = 'repo_interrupt',
    MAX_TRANSACTION_RETRIES = 25;
class Repo {
    constructor(e, t, n, r) {
        (this.repoInfo_ = e),
            (this.forceRestClient_ = t),
            (this.authTokenProvider_ = n),
            (this.appCheckProvider_ = r),
            (this.dataUpdateCount = 0),
            (this.statsListener_ = null),
            (this.eventQueue_ = new EventQueue()),
            (this.nextWriteId_ = 1),
            (this.interceptServerDataCallback_ = null),
            (this.onDisconnect_ = newSparseSnapshotTree()),
            (this.transactionQueueTree_ = new Tree()),
            (this.persistentConnection_ = null),
            (this.key = this.repoInfo_.toURLString());
    }
    toString() {
        return (
            (this.repoInfo_.secure ? 'https://' : 'http://') +
            this.repoInfo_.host
        );
    }
}
function repoStart(s, e, t) {
    if (
        ((s.stats_ = statsManagerGetCollection(s.repoInfo_)),
        s.forceRestClient_ || beingCrawled())
    )
        (s.server_ = new ReadonlyRestClient(
            s.repoInfo_,
            (e, t, n, r) => {
                repoOnDataUpdate(s, e, t, n, r);
            },
            s.authTokenProvider_,
            s.appCheckProvider_
        )),
            setTimeout(() => repoOnConnectStatus(s, !0), 0);
    else {
        if (null != t) {
            if ('object' != typeof t)
                throw new Error(
                    'Only objects are supported for option databaseAuthVariableOverride'
                );
            try {
                stringify(t);
            } catch (e) {
                throw new Error('Invalid authOverride provided: ' + e);
            }
        }
        (s.persistentConnection_ = new PersistentConnection(
            s.repoInfo_,
            e,
            (e, t, n, r) => {
                repoOnDataUpdate(s, e, t, n, r);
            },
            (e) => {
                repoOnConnectStatus(s, e);
            },
            (e) => {
                repoOnServerInfoUpdate(s, e);
            },
            s.authTokenProvider_,
            s.appCheckProvider_,
            t
        )),
            (s.server_ = s.persistentConnection_);
    }
    s.authTokenProvider_.addTokenChangeListener((e) => {
        s.server_.refreshAuthToken(e);
    }),
        s.appCheckProvider_.addTokenChangeListener((e) => {
            s.server_.refreshAppCheckToken(e.token);
        }),
        (s.statsReporter_ = statsManagerGetOrCreateReporter(
            s.repoInfo_,
            () => new StatsReporter(s.stats_, s.server_)
        )),
        (s.infoData_ = new SnapshotHolder()),
        (s.infoSyncTree_ = new SyncTree({
            startListening: (e, t, n, r) => {
                let i = [];
                const o = s.infoData_.getNode(e._path);
                return (
                    o.isEmpty() ||
                        ((i = syncTreeApplyServerOverwrite(
                            s.infoSyncTree_,
                            e._path,
                            o
                        )),
                        setTimeout(() => {
                            r('ok');
                        }, 0)),
                    i
                );
            },
            stopListening: () => {},
        })),
        repoUpdateInfo(s, 'connected', !1),
        (s.serverSyncTree_ = new SyncTree({
            startListening: (n, e, t, r) => (
                s.server_.listen(n, t, e, (e, t) => {
                    t = r(e, t);
                    eventQueueRaiseEventsForChangedPath(
                        s.eventQueue_,
                        n._path,
                        t
                    );
                }),
                []
            ),
            stopListening: (e, t) => {
                s.server_.unlisten(e, t);
            },
        }));
}
function repoServerTime(e) {
    const t = e.infoData_.getNode(new Path('.info/serverTimeOffset'));
    e = t.val() || 0;
    return new Date().getTime() + e;
}
function repoGenerateServerValues(e) {
    return generateWithValues({ timestamp: repoServerTime(e) });
}
function repoOnDataUpdate(e, t, n, r, i) {
    e.dataUpdateCount++;
    var o,
        s = new Path(t);
    n = e.interceptServerDataCallback_
        ? e.interceptServerDataCallback_(t, n)
        : n;
    let a = [];
    a = i
        ? r
            ? ((o = map(n, (e) => nodeFromJSON(e))),
              syncTreeApplyTaggedQueryMerge(e.serverSyncTree_, s, o, i))
            : ((o = nodeFromJSON(n)),
              syncTreeApplyTaggedQueryOverwrite(e.serverSyncTree_, s, o, i))
        : r
        ? ((r = map(n, (e) => nodeFromJSON(e))),
          syncTreeApplyServerMerge(e.serverSyncTree_, s, r))
        : ((n = nodeFromJSON(n)),
          syncTreeApplyServerOverwrite(e.serverSyncTree_, s, n));
    let l = s;
    0 < a.length && (l = repoRerunTransactions(e, s)),
        eventQueueRaiseEventsForChangedPath(e.eventQueue_, l, a);
}
function repoOnConnectStatus(e, t) {
    repoUpdateInfo(e, 'connected', t), !1 === t && repoRunOnDisconnectEvents(e);
}
function repoOnServerInfoUpdate(n, e) {
    each(e, (e, t) => {
        repoUpdateInfo(n, e, t);
    });
}
function repoUpdateInfo(e, t, n) {
    (t = new Path('/.info/' + t)), (n = nodeFromJSON(n));
    e.infoData_.updateSnapshot(t, n);
    n = syncTreeApplyServerOverwrite(e.infoSyncTree_, t, n);
    eventQueueRaiseEventsForChangedPath(e.eventQueue_, t, n);
}
function repoGetNextWriteId(e) {
    return e.nextWriteId_++;
}
function repoGetValue(n, r) {
    var e = syncTreeGetServerValue(n.serverSyncTree_, r);
    return null != e
        ? Promise.resolve(e)
        : n.server_.get(r).then(
              (e) => {
                  var t = nodeFromJSON(e).withIndex(r._queryParams.getIndex()),
                      e = syncTreeApplyServerOverwrite(
                          n.serverSyncTree_,
                          r._path,
                          t
                      );
                  return (
                      eventQueueRaiseEventsAtPath(n.eventQueue_, r._path, e),
                      Promise.resolve(t)
                  );
              },
              (e) => (
                  repoLog(n, 'get for query ' + stringify(r) + ' failed: ' + e),
                  Promise.reject(new Error(e))
              )
          );
}
function repoSetWithPriority(r, i, e, t, o) {
    repoLog(r, 'set', { path: i.toString(), value: e, priority: t });
    var n = repoGenerateServerValues(r);
    const s = nodeFromJSON(e, t);
    (t = syncTreeCalcCompleteEventCache(r.serverSyncTree_, i)),
        (n = resolveDeferredValueSnapshot(s, t, n));
    const a = repoGetNextWriteId(r);
    n = syncTreeApplyUserOverwrite(r.serverSyncTree_, i, n, a, !0);
    eventQueueQueueEvents(r.eventQueue_, n),
        r.server_.put(i.toString(), s.val(!0), (e, t) => {
            var n = 'ok' === e;
            n || warn('set at ' + i + ' failed: ' + e);
            n = syncTreeAckUserWrite(r.serverSyncTree_, a, !n);
            eventQueueRaiseEventsForChangedPath(r.eventQueue_, i, n),
                repoCallOnCompleteCallback(r, o, e, t);
        });
    n = repoAbortTransactions(r, i);
    repoRerunTransactions(r, n),
        eventQueueRaiseEventsForChangedPath(r.eventQueue_, n, []);
}
function repoUpdate(i, o, e, s) {
    repoLog(i, 'update', { path: o.toString(), value: e });
    let n = !0;
    const r = repoGenerateServerValues(i),
        a = {};
    if (
        (each(e, (e, t) => {
            (n = !1),
                (a[e] = resolveDeferredValueTree(
                    pathChild(o, e),
                    nodeFromJSON(t),
                    i.serverSyncTree_,
                    r
                ));
        }),
        n)
    )
        log("update() called with empty data.  Don't do anything."),
            repoCallOnCompleteCallback(i, s, 'ok', void 0);
    else {
        const l = repoGetNextWriteId(i);
        var t = syncTreeApplyUserMerge(i.serverSyncTree_, o, a, l);
        eventQueueQueueEvents(i.eventQueue_, t),
            i.server_.merge(o.toString(), e, (e, t) => {
                var n = 'ok' === e;
                n || warn('update at ' + o + ' failed: ' + e);
                var r = syncTreeAckUserWrite(i.serverSyncTree_, l, !n),
                    n = 0 < r.length ? repoRerunTransactions(i, o) : o;
                eventQueueRaiseEventsForChangedPath(i.eventQueue_, n, r),
                    repoCallOnCompleteCallback(i, s, e, t);
            }),
            each(e, (e) => {
                e = repoAbortTransactions(i, pathChild(o, e));
                repoRerunTransactions(i, e);
            }),
            eventQueueRaiseEventsForChangedPath(i.eventQueue_, o, []);
    }
}
function repoRunOnDisconnectEvents(n) {
    repoLog(n, 'onDisconnectEvents');
    const r = repoGenerateServerValues(n),
        i = newSparseSnapshotTree();
    sparseSnapshotTreeForEachTree(n.onDisconnect_, newEmptyPath(), (e, t) => {
        t = resolveDeferredValueTree(e, t, n.serverSyncTree_, r);
        sparseSnapshotTreeRemember(i, e, t);
    });
    let o = [];
    sparseSnapshotTreeForEachTree(i, newEmptyPath(), (e, t) => {
        o = o.concat(syncTreeApplyServerOverwrite(n.serverSyncTree_, e, t));
        e = repoAbortTransactions(n, e);
        repoRerunTransactions(n, e);
    }),
        (n.onDisconnect_ = newSparseSnapshotTree()),
        eventQueueRaiseEventsForChangedPath(n.eventQueue_, newEmptyPath(), o);
}
function repoOnDisconnectCancel(n, r, i) {
    n.server_.onDisconnectCancel(r.toString(), (e, t) => {
        'ok' === e && sparseSnapshotTreeForget(n.onDisconnect_, r),
            repoCallOnCompleteCallback(n, i, e, t);
    });
}
function repoOnDisconnectSet(n, r, e, i) {
    const o = nodeFromJSON(e);
    n.server_.onDisconnectPut(r.toString(), o.val(!0), (e, t) => {
        'ok' === e && sparseSnapshotTreeRemember(n.onDisconnect_, r, o),
            repoCallOnCompleteCallback(n, i, e, t);
    });
}
function repoOnDisconnectSetWithPriority(n, r, e, t, i) {
    const o = nodeFromJSON(e, t);
    n.server_.onDisconnectPut(r.toString(), o.val(!0), (e, t) => {
        'ok' === e && sparseSnapshotTreeRemember(n.onDisconnect_, r, o),
            repoCallOnCompleteCallback(n, i, e, t);
    });
}
function repoOnDisconnectUpdate(n, r, i, o) {
    if (isEmpty(i))
        return (
            log(
                "onDisconnect().update() called with empty data.  Don't do anything."
            ),
            void repoCallOnCompleteCallback(n, o, 'ok', void 0)
        );
    n.server_.onDisconnectMerge(r.toString(), i, (e, t) => {
        'ok' === e &&
            each(i, (e, t) => {
                t = nodeFromJSON(t);
                sparseSnapshotTreeRemember(n.onDisconnect_, pathChild(r, e), t);
            }),
            repoCallOnCompleteCallback(n, o, e, t);
    });
}
function repoAddEventCallbackForQuery(e, t, n) {
    let r;
    (r =
        '.info' === pathGetFront(t._path)
            ? syncTreeAddEventRegistration(e.infoSyncTree_, t, n)
            : syncTreeAddEventRegistration(e.serverSyncTree_, t, n)),
        eventQueueRaiseEventsAtPath(e.eventQueue_, t._path, r);
}
function repoRemoveEventCallbackForQuery(e, t, n) {
    let r;
    (r =
        '.info' === pathGetFront(t._path)
            ? syncTreeRemoveEventRegistration(e.infoSyncTree_, t, n)
            : syncTreeRemoveEventRegistration(e.serverSyncTree_, t, n)),
        eventQueueRaiseEventsAtPath(e.eventQueue_, t._path, r);
}
function repoInterrupt(e) {
    e.persistentConnection_ &&
        e.persistentConnection_.interrupt(INTERRUPT_REASON);
}
function repoResume(e) {
    e.persistentConnection_ && e.persistentConnection_.resume(INTERRUPT_REASON);
}
function repoLog(e, ...t) {
    let n = '';
    e.persistentConnection_ && (n = e.persistentConnection_.id + ':'),
        log(n, ...t);
}
function repoCallOnCompleteCallback(e, r, i, o) {
    r &&
        exceptionGuard(() => {
            if ('ok' === i) r(null);
            else {
                var t = (i || 'error').toUpperCase();
                let e = t;
                o && (e += ': ' + o);
                const n = new Error(e);
                (n.code = t), r(n);
            }
        });
}
function repoStartTransaction(t, n, e, r, i, o) {
    repoLog(t, 'transaction on ' + n);
    const s = {
            path: n,
            update: e,
            onComplete: r,
            status: null,
            order: LUIDGenerator(),
            applyLocally: o,
            retryCount: 0,
            unwatcher: i,
            abortReason: null,
            currentWriteId: null,
            currentInputSnapshot: null,
            currentOutputSnapshotRaw: null,
            currentOutputSnapshotResolved: null,
        },
        a = repoGetLatestState(t, n, void 0);
    s.currentInputSnapshot = a;
    o = s.update(a.val());
    if (void 0 === o)
        s.unwatcher(),
            (s.currentOutputSnapshotRaw = null),
            (s.currentOutputSnapshotResolved = null),
            s.onComplete && s.onComplete(null, !1, s.currentInputSnapshot);
    else {
        validateFirebaseData('transaction failed: Data returned ', o, s.path),
            (s.status = 0);
        i = treeSubTree(t.transactionQueueTree_, n);
        const l = treeGetValue(i) || [];
        l.push(s), treeSetValue(i, l);
        let e;
        if ('object' == typeof o && null !== o && contains(o, '.priority'))
            (e = safeGet(o, '.priority')),
                assert(
                    isValidPriority(e),
                    'Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.'
                );
        else {
            const h =
                syncTreeCalcCompleteEventCache(t.serverSyncTree_, n) ||
                ChildrenNode.EMPTY_NODE;
            e = h.getPriority().val();
        }
        (i = repoGenerateServerValues(t)),
            (o = nodeFromJSON(o, e)),
            (i = resolveDeferredValueSnapshot(o, a, i));
        (s.currentOutputSnapshotRaw = o),
            (s.currentOutputSnapshotResolved = i),
            (s.currentWriteId = repoGetNextWriteId(t));
        i = syncTreeApplyUserOverwrite(
            t.serverSyncTree_,
            n,
            i,
            s.currentWriteId,
            s.applyLocally
        );
        eventQueueRaiseEventsForChangedPath(t.eventQueue_, n, i),
            repoSendReadyTransactions(t, t.transactionQueueTree_);
    }
}
function repoGetLatestState(e, t, n) {
    return (
        syncTreeCalcCompleteEventCache(e.serverSyncTree_, t, n) ||
        ChildrenNode.EMPTY_NODE
    );
}
function repoSendReadyTransactions(t, e = t.transactionQueueTree_) {
    if ((e || repoPruneCompletedTransactionsBelowNode(t, e), treeGetValue(e))) {
        const n = repoBuildTransactionQueue(t, e);
        assert(0 < n.length, 'Sending zero length transaction queue'),
            n.every((e) => 0 === e.status) &&
                repoSendTransactionQueue(t, treeGetPath(e), n);
    } else
        treeHasChildren(e) &&
            treeForEachChild(e, (e) => {
                repoSendReadyTransactions(t, e);
            });
}
function repoSendTransactionQueue(i, o, s) {
    var e = s.map((e) => e.currentWriteId);
    const t = repoGetLatestState(i, o, e);
    let n = t;
    var r = t.hash();
    for (let e = 0; e < s.length; e++) {
        const h = s[e];
        assert(
            0 === h.status,
            'tryToSendTransactionQueue_: items in queue should all be run.'
        ),
            (h.status = 1),
            h.retryCount++;
        var a = newRelativePath(o, h.path);
        n = n.updateChild(a, h.currentOutputSnapshotRaw);
    }
    e = n.val(!0);
    const l = o;
    i.server_.put(
        l.toString(),
        e,
        (t) => {
            repoLog(i, 'transaction put response', {
                path: l.toString(),
                status: t,
            });
            let n = [];
            if ('ok' === t) {
                const r = [];
                for (let e = 0; e < s.length; e++)
                    (s[e].status = 2),
                        (n = n.concat(
                            syncTreeAckUserWrite(
                                i.serverSyncTree_,
                                s[e].currentWriteId
                            )
                        )),
                        s[e].onComplete &&
                            r.push(() =>
                                s[e].onComplete(
                                    null,
                                    !0,
                                    s[e].currentOutputSnapshotResolved
                                )
                            ),
                        s[e].unwatcher();
                repoPruneCompletedTransactionsBelowNode(
                    i,
                    treeSubTree(i.transactionQueueTree_, o)
                ),
                    repoSendReadyTransactions(i, i.transactionQueueTree_),
                    eventQueueRaiseEventsForChangedPath(i.eventQueue_, o, n);
                for (let e = 0; e < r.length; e++) exceptionGuard(r[e]);
            } else {
                if ('datastale' === t)
                    for (let e = 0; e < s.length; e++)
                        3 === s[e].status
                            ? (s[e].status = 4)
                            : (s[e].status = 0);
                else {
                    warn('transaction at ' + l.toString() + ' failed: ' + t);
                    for (let e = 0; e < s.length; e++)
                        (s[e].status = 4), (s[e].abortReason = t);
                }
                repoRerunTransactions(i, o);
            }
        },
        r
    );
}
function repoRerunTransactions(e, t) {
    var n = repoGetAncestorTransactionNode(e, t),
        t = treeGetPath(n);
    return repoRerunTransactionQueue(e, repoBuildTransactionQueue(e, n), t), t;
}
function repoRerunTransactionQueue(i, o, s) {
    if (0 !== o.length) {
        const h = [];
        let r = [];
        const e = o.filter((e) => 0 === e.status),
            c = e.map((e) => e.currentWriteId);
        for (let n = 0; n < o.length; n++) {
            const d = o[n];
            var a = newRelativePath(s, d.path);
            let e = !1,
                t;
            if (
                (assert(
                    null !== a,
                    'rerunTransactionsUnderNode_: relativePath should not be null.'
                ),
                4 === d.status)
            )
                (e = !0),
                    (t = d.abortReason),
                    (r = r.concat(
                        syncTreeAckUserWrite(
                            i.serverSyncTree_,
                            d.currentWriteId,
                            !0
                        )
                    ));
            else if (0 === d.status)
                if (d.retryCount >= MAX_TRANSACTION_RETRIES)
                    (e = !0),
                        (t = 'maxretry'),
                        (r = r.concat(
                            syncTreeAckUserWrite(
                                i.serverSyncTree_,
                                d.currentWriteId,
                                !0
                            )
                        ));
                else {
                    const u = repoGetLatestState(i, d.path, c);
                    d.currentInputSnapshot = u;
                    a = o[n].update(u.val());
                    if (void 0 !== a) {
                        validateFirebaseData(
                            'transaction failed: Data returned ',
                            a,
                            d.path
                        );
                        let e = nodeFromJSON(a);
                        ('object' == typeof a &&
                            null != a &&
                            contains(a, '.priority')) ||
                            (e = e.updatePriority(u.getPriority()));
                        var l = d.currentWriteId,
                            a = repoGenerateServerValues(i),
                            a = resolveDeferredValueSnapshot(e, u, a);
                        (d.currentOutputSnapshotRaw = e),
                            (d.currentOutputSnapshotResolved = a),
                            (d.currentWriteId = repoGetNextWriteId(i)),
                            c.splice(c.indexOf(l), 1),
                            (r = r.concat(
                                syncTreeApplyUserOverwrite(
                                    i.serverSyncTree_,
                                    d.path,
                                    a,
                                    d.currentWriteId,
                                    d.applyLocally
                                )
                            )),
                            (r = r.concat(
                                syncTreeAckUserWrite(i.serverSyncTree_, l, !0)
                            ));
                    } else
                        (e = !0),
                            (t = 'nodata'),
                            (r = r.concat(
                                syncTreeAckUserWrite(
                                    i.serverSyncTree_,
                                    d.currentWriteId,
                                    !0
                                )
                            ));
                }
            eventQueueRaiseEventsForChangedPath(i.eventQueue_, s, r),
                (r = []),
                e &&
                    ((o[n].status = 2),
                    (l = o[n].unwatcher),
                    setTimeout(l, Math.floor(0)),
                    o[n].onComplete &&
                        ('nodata' === t
                            ? h.push(() =>
                                  o[n].onComplete(
                                      null,
                                      !1,
                                      o[n].currentInputSnapshot
                                  )
                              )
                            : h.push(() =>
                                  o[n].onComplete(new Error(t), !1, null)
                              )));
        }
        repoPruneCompletedTransactionsBelowNode(i, i.transactionQueueTree_);
        for (let e = 0; e < h.length; e++) exceptionGuard(h[e]);
        repoSendReadyTransactions(i, i.transactionQueueTree_);
    }
}
function repoGetAncestorTransactionNode(e, t) {
    let n,
        r = e.transactionQueueTree_;
    for (n = pathGetFront(t); null !== n && void 0 === treeGetValue(r); )
        (r = treeSubTree(r, n)), (t = pathPopFront(t)), (n = pathGetFront(t));
    return r;
}
function repoBuildTransactionQueue(e, t) {
    const n = [];
    return (
        repoAggregateTransactionQueuesForNode(e, t, n),
        n.sort((e, t) => e.order - t.order),
        n
    );
}
function repoAggregateTransactionQueuesForNode(t, e, n) {
    var r = treeGetValue(e);
    if (r) for (let e = 0; e < r.length; e++) n.push(r[e]);
    treeForEachChild(e, (e) => {
        repoAggregateTransactionQueuesForNode(t, e, n);
    });
}
function repoPruneCompletedTransactionsBelowNode(t, e) {
    const n = treeGetValue(e);
    if (n) {
        let t = 0;
        for (let e = 0; e < n.length; e++)
            2 !== n[e].status && ((n[t] = n[e]), t++);
        (n.length = t), treeSetValue(e, 0 < n.length ? n : void 0);
    }
    treeForEachChild(e, (e) => {
        repoPruneCompletedTransactionsBelowNode(t, e);
    });
}
function repoAbortTransactions(t, e) {
    var n = treeGetPath(repoGetAncestorTransactionNode(t, e)),
        e = treeSubTree(t.transactionQueueTree_, e);
    return (
        treeForEachAncestor(e, (e) => {
            repoAbortTransactionsOnNode(t, e);
        }),
        repoAbortTransactionsOnNode(t, e),
        treeForEachDescendant(e, (e) => {
            repoAbortTransactionsOnNode(t, e);
        }),
        n
    );
}
function repoAbortTransactionsOnNode(r, e) {
    const i = treeGetValue(e);
    if (i) {
        const o = [];
        let t = [],
            n = -1;
        for (let e = 0; e < i.length; e++)
            3 === i[e].status ||
                (1 === i[e].status
                    ? (assert(
                          n === e - 1,
                          'All SENT items should be at beginning of queue.'
                      ),
                      (n = e),
                      (i[e].status = 3),
                      (i[e].abortReason = 'set'))
                    : (assert(
                          0 === i[e].status,
                          'Unexpected transaction status in abort'
                      ),
                      i[e].unwatcher(),
                      (t = t.concat(
                          syncTreeAckUserWrite(
                              r.serverSyncTree_,
                              i[e].currentWriteId,
                              !0
                          )
                      )),
                      i[e].onComplete &&
                          o.push(
                              i[e].onComplete.bind(
                                  null,
                                  new Error('set'),
                                  !1,
                                  null
                              )
                          )));
        -1 === n ? treeSetValue(e, void 0) : (i.length = n + 1),
            eventQueueRaiseEventsForChangedPath(
                r.eventQueue_,
                treeGetPath(e),
                t
            );
        for (let e = 0; e < o.length; e++) exceptionGuard(o[e]);
    }
}
function decodePath(e) {
    let n = '';
    var r = e.split('/');
    for (let t = 0; t < r.length; t++)
        if (0 < r[t].length) {
            let e = r[t];
            try {
                e = decodeURIComponent(e.replace(/\+/g, ' '));
            } catch (e) {}
            n += '/' + e;
        }
    return n;
}
function decodeQuery(e) {
    const t = {};
    for (const r of (e = '?' === e.charAt(0) ? e.substring(1) : e).split('&')) {
        var n;
        0 !== r.length &&
            (2 === (n = r.split('=')).length
                ? (t[decodeURIComponent(n[0])] = decodeURIComponent(n[1]))
                : warn(`Invalid query segment '${r}' in query '${e}'`));
    }
    return t;
}
const parseRepoInfo = function (e, t) {
        var n = parseDatabaseURL(e),
            r = n.namespace;
        'firebase.com' === n.domain &&
            fatal(
                n.host +
                    ' is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead'
            ),
            (r && 'undefined' !== r) ||
                'localhost' === n.domain ||
                fatal(
                    'Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com'
                ),
            n.secure || warnIfPageIsSecure();
        e = 'ws' === n.scheme || 'wss' === n.scheme;
        return {
            repoInfo: new RepoInfo(
                n.host,
                n.secure,
                r,
                t,
                e,
                '',
                r !== n.subdomain
            ),
            path: new Path(n.pathString),
        };
    },
    parseDatabaseURL = function (r) {
        let i = '',
            o = '',
            s = '',
            a = '',
            l = '',
            h = !0,
            c = 'https',
            d = 443;
        if ('string' == typeof r) {
            let e = r.indexOf('//');
            0 <= e && ((c = r.substring(0, e - 1)), (r = r.substring(e + 2)));
            let t = r.indexOf('/');
            -1 === t && (t = r.length);
            let n = r.indexOf('?');
            -1 === n && (n = r.length),
                (i = r.substring(0, Math.min(t, n))),
                t < n && (a = decodePath(r.substring(t, n)));
            var u = decodeQuery(r.substring(Math.min(r.length, n)));
            (e = i.indexOf(':')),
                0 <= e
                    ? ((h = 'https' === c || 'wss' === c),
                      (d = parseInt(i.substring(e + 1), 10)))
                    : (e = i.length);
            const p = i.slice(0, e);
            'localhost' === p.toLowerCase()
                ? (o = 'localhost')
                : p.split('.').length <= 2
                ? (o = p)
                : ((r = i.indexOf('.')),
                  (s = i.substring(0, r).toLowerCase()),
                  (o = i.substring(r + 1)),
                  (l = s)),
                'ns' in u && (l = u.ns);
        }
        return {
            host: i,
            port: d,
            domain: o,
            subdomain: s,
            secure: h,
            scheme: c,
            pathString: a,
            namespace: l,
        };
    };
class DataEvent {
    constructor(e, t, n, r) {
        (this.eventType = e),
            (this.eventRegistration = t),
            (this.snapshot = n),
            (this.prevName = r);
    }
    getPath() {
        var e = this.snapshot.ref;
        return ('value' === this.eventType ? e : e.parent)._path;
    }
    getEventType() {
        return this.eventType;
    }
    getEventRunner() {
        return this.eventRegistration.getEventRunner(this);
    }
    toString() {
        return (
            this.getPath().toString() +
            ':' +
            this.eventType +
            ':' +
            stringify(this.snapshot.exportVal())
        );
    }
}
class CancelEvent {
    constructor(e, t, n) {
        (this.eventRegistration = e), (this.error = t), (this.path = n);
    }
    getPath() {
        return this.path;
    }
    getEventType() {
        return 'cancel';
    }
    getEventRunner() {
        return this.eventRegistration.getEventRunner(this);
    }
    toString() {
        return this.path.toString() + ':cancel';
    }
}
class CallbackContext {
    constructor(e, t) {
        (this.snapshotCallback = e), (this.cancelCallback = t);
    }
    onValue(e, t) {
        this.snapshotCallback.call(null, e, t);
    }
    onCancel(e) {
        return (
            assert(
                this.hasCancelCallback,
                'Raising a cancel event on a listener with no cancel callback'
            ),
            this.cancelCallback.call(null, e)
        );
    }
    get hasCancelCallback() {
        return !!this.cancelCallback;
    }
    matches(e) {
        return (
            this.snapshotCallback === e.snapshotCallback ||
            (void 0 !== this.snapshotCallback.userCallback &&
                this.snapshotCallback.userCallback ===
                    e.snapshotCallback.userCallback &&
                this.snapshotCallback.context === e.snapshotCallback.context)
        );
    }
}
class OnDisconnect {
    constructor(e, t) {
        (this._repo = e), (this._path = t);
    }
    cancel() {
        const e = new Deferred();
        return (
            repoOnDisconnectCancel(
                this._repo,
                this._path,
                e.wrapCallback(() => {})
            ),
            e.promise
        );
    }
    remove() {
        validateWritablePath('OnDisconnect.remove', this._path);
        const e = new Deferred();
        return (
            repoOnDisconnectSet(
                this._repo,
                this._path,
                null,
                e.wrapCallback(() => {})
            ),
            e.promise
        );
    }
    set(e) {
        validateWritablePath('OnDisconnect.set', this._path),
            validateFirebaseDataArg('OnDisconnect.set', e, this._path, !1);
        const t = new Deferred();
        return (
            repoOnDisconnectSet(
                this._repo,
                this._path,
                e,
                t.wrapCallback(() => {})
            ),
            t.promise
        );
    }
    setWithPriority(e, t) {
        validateWritablePath('OnDisconnect.setWithPriority', this._path),
            validateFirebaseDataArg(
                'OnDisconnect.setWithPriority',
                e,
                this._path,
                !1
            ),
            validatePriority('OnDisconnect.setWithPriority', t, !1);
        const n = new Deferred();
        return (
            repoOnDisconnectSetWithPriority(
                this._repo,
                this._path,
                e,
                t,
                n.wrapCallback(() => {})
            ),
            n.promise
        );
    }
    update(e) {
        validateWritablePath('OnDisconnect.update', this._path),
            validateFirebaseMergeDataArg(
                'OnDisconnect.update',
                e,
                this._path,
                !1
            );
        const t = new Deferred();
        return (
            repoOnDisconnectUpdate(
                this._repo,
                this._path,
                e,
                t.wrapCallback(() => {})
            ),
            t.promise
        );
    }
}
class QueryImpl {
    constructor(e, t, n, r) {
        (this._repo = e),
            (this._path = t),
            (this._queryParams = n),
            (this._orderByCalled = r);
    }
    get key() {
        return pathIsEmpty(this._path) ? null : pathGetBack(this._path);
    }
    get ref() {
        return new ReferenceImpl(this._repo, this._path);
    }
    get _queryIdentifier() {
        var e = queryParamsGetQueryObject(this._queryParams),
            e = ObjectToUniqueKey(e);
        return '{}' === e ? 'default' : e;
    }
    get _queryObject() {
        return queryParamsGetQueryObject(this._queryParams);
    }
    isEqual(e) {
        if (!((e = getModularInstance(e)) instanceof QueryImpl)) return !1;
        var t = this._repo === e._repo,
            n = pathEquals(this._path, e._path),
            e = this._queryIdentifier === e._queryIdentifier;
        return t && n && e;
    }
    toJSON() {
        return this.toString();
    }
    toString() {
        return this._repo.toString() + pathToUrlEncodedString(this._path);
    }
}
function validateNoPreviousOrderByCall(e, t) {
    if (!0 === e._orderByCalled)
        throw new Error(t + ": You can't combine multiple orderBy calls.");
}
function validateQueryEndpoints(e) {
    let t = null,
        n = null;
    if (
        (e.hasStart() && (t = e.getIndexStartValue()),
        e.hasEnd() && (n = e.getIndexEndValue()),
        e.getIndex() === KEY_INDEX)
    ) {
        var r =
                'Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().',
            i =
                'Query: When ordering by key, the argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() must be a string.';
        if (e.hasStart()) {
            if (e.getIndexStartName() !== MIN_NAME) throw new Error(r);
            if ('string' != typeof t) throw new Error(i);
        }
        if (e.hasEnd()) {
            if (e.getIndexEndName() !== MAX_NAME) throw new Error(r);
            if ('string' != typeof n) throw new Error(i);
        }
    } else if (e.getIndex() === PRIORITY_INDEX) {
        if (
            (null != t && !isValidPriority(t)) ||
            (null != n && !isValidPriority(n))
        )
            throw new Error(
                'Query: When ordering by priority, the first argument passed to startAt(), startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value (null, a number, or a string).'
            );
    } else if (
        (assert(
            e.getIndex() instanceof PathIndex || e.getIndex() === VALUE_INDEX,
            'unknown index type.'
        ),
        (null != t && 'object' == typeof t) ||
            (null != n && 'object' == typeof n))
    )
        throw new Error(
            'Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() cannot be an object.'
        );
}
function validateLimit(e) {
    if (e.hasStart() && e.hasEnd() && e.hasLimit() && !e.hasAnchoredLimit())
        throw new Error(
            "Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use limitToFirst() or limitToLast() instead."
        );
}
class ReferenceImpl extends QueryImpl {
    constructor(e, t) {
        super(e, t, new QueryParams(), !1);
    }
    get parent() {
        var e = pathParent(this._path);
        return null === e ? null : new ReferenceImpl(this._repo, e);
    }
    get root() {
        let e = this;
        for (; null !== e.parent; ) e = e.parent;
        return e;
    }
}
class DataSnapshot {
    constructor(e, t, n) {
        (this._node = e), (this.ref = t), (this._index = n);
    }
    get priority() {
        return this._node.getPriority().val();
    }
    get key() {
        return this.ref.key;
    }
    get size() {
        return this._node.numChildren();
    }
    child(e) {
        var t = new Path(e),
            e = child(this.ref, e);
        return new DataSnapshot(this._node.getChild(t), e, PRIORITY_INDEX);
    }
    exists() {
        return !this._node.isEmpty();
    }
    exportVal() {
        return this._node.val(!0);
    }
    forEach(n) {
        if (this._node.isLeafNode()) return !1;
        const e = this._node;
        return !!e.forEachChild(this._index, (e, t) =>
            n(new DataSnapshot(t, child(this.ref, e), PRIORITY_INDEX))
        );
    }
    hasChild(e) {
        e = new Path(e);
        return !this._node.getChild(e).isEmpty();
    }
    hasChildren() {
        return !this._node.isLeafNode() && !this._node.isEmpty();
    }
    toJSON() {
        return this.exportVal();
    }
    val() {
        return this._node.val();
    }
}
function ref(e, t) {
    return (
        (e = getModularInstance(e))._checkNotDeleted('ref'),
        void 0 !== t ? child(e._root, t) : e._root
    );
}
function refFromURL(e, t) {
    (e = getModularInstance(e))._checkNotDeleted('refFromURL');
    const n = parseRepoInfo(t, e._repo.repoInfo_.nodeAdmin);
    validateUrl('refFromURL', n);
    t = n.repoInfo;
    return (
        e._repo.repoInfo_.isCustomHost() ||
            t.host === e._repo.repoInfo_.host ||
            fatal(
                'refFromURL: Host name does not match the current database: (found ' +
                    t.host +
                    ' but expected ' +
                    e._repo.repoInfo_.host +
                    ')'
            ),
        ref(e, n.path.toString())
    );
}
function child(e, t) {
    return (
        (null === pathGetFront((e = getModularInstance(e))._path)
            ? validateRootPathString
            : validatePathString)('child', 'path', t, !1),
        new ReferenceImpl(e._repo, pathChild(e._path, t))
    );
}
function onDisconnect(e) {
    return (e = getModularInstance(e)), new OnDisconnect(e._repo, e._path);
}
function push(e, t) {
    (e = getModularInstance(e)),
        validateWritablePath('push', e._path),
        validateFirebaseDataArg('push', t, e._path, !0);
    var n = repoServerTime(e._repo),
        n = nextPushId(n);
    const r = child(e, n),
        i = child(e, n);
    let o;
    return (
        (o = null != t ? set(i, t).then(() => i) : Promise.resolve(i)),
        (r.then = o.then.bind(o)),
        (r.catch = o.then.bind(o, void 0)),
        r
    );
}
function remove(e) {
    return validateWritablePath('remove', e._path), set(e, null);
}
function set(e, t) {
    (e = getModularInstance(e)),
        validateWritablePath('set', e._path),
        validateFirebaseDataArg('set', t, e._path, !1);
    const n = new Deferred();
    return (
        repoSetWithPriority(
            e._repo,
            e._path,
            t,
            null,
            n.wrapCallback(() => {})
        ),
        n.promise
    );
}
function setPriority(e, t) {
    (e = getModularInstance(e)),
        validateWritablePath('setPriority', e._path),
        validatePriority('setPriority', t, !1);
    const n = new Deferred();
    return (
        repoSetWithPriority(
            e._repo,
            pathChild(e._path, '.priority'),
            t,
            null,
            n.wrapCallback(() => {})
        ),
        n.promise
    );
}
function setWithPriority(e, t, n) {
    if (
        (validateWritablePath('setWithPriority', e._path),
        validateFirebaseDataArg('setWithPriority', t, e._path, !1),
        validatePriority('setWithPriority', n, !1),
        '.length' === e.key || '.keys' === e.key)
    )
        throw 'setWithPriority failed: ' + e.key + ' is a read-only object.';
    const r = new Deferred();
    return (
        repoSetWithPriority(
            e._repo,
            e._path,
            t,
            n,
            r.wrapCallback(() => {})
        ),
        r.promise
    );
}
function update(e, t) {
    validateFirebaseMergeDataArg('update', t, e._path, !1);
    const n = new Deferred();
    return (
        repoUpdate(
            e._repo,
            e._path,
            t,
            n.wrapCallback(() => {})
        ),
        n.promise
    );
}
function get(t) {
    return repoGetValue((t = getModularInstance(t))._repo, t).then(
        (e) =>
            new DataSnapshot(
                e,
                new ReferenceImpl(t._repo, t._path),
                t._queryParams.getIndex()
            )
    );
}
class ValueEventRegistration {
    constructor(e) {
        this.callbackContext = e;
    }
    respondsTo(e) {
        return 'value' === e;
    }
    createEvent(e, t) {
        var n = t._queryParams.getIndex();
        return new DataEvent(
            'value',
            this,
            new DataSnapshot(
                e.snapshotNode,
                new ReferenceImpl(t._repo, t._path),
                n
            )
        );
    }
    getEventRunner(e) {
        return 'cancel' === e.getEventType()
            ? () => this.callbackContext.onCancel(e.error)
            : () => this.callbackContext.onValue(e.snapshot, null);
    }
    createCancelEvent(e, t) {
        return this.callbackContext.hasCancelCallback
            ? new CancelEvent(this, e, t)
            : null;
    }
    matches(e) {
        return (
            e instanceof ValueEventRegistration &&
            (!e.callbackContext ||
                !this.callbackContext ||
                e.callbackContext.matches(this.callbackContext))
        );
    }
    hasAnyCallback() {
        return null !== this.callbackContext;
    }
}
class ChildEventRegistration {
    constructor(e, t) {
        (this.eventType = e), (this.callbackContext = t);
    }
    respondsTo(e) {
        let t = 'children_added' === e ? 'child_added' : e;
        return (
            (t = 'children_removed' === t ? 'child_removed' : t),
            this.eventType === t
        );
    }
    createCancelEvent(e, t) {
        return this.callbackContext.hasCancelCallback
            ? new CancelEvent(this, e, t)
            : null;
    }
    createEvent(e, t) {
        assert(null != e.childName, 'Child events should have a childName.');
        var n = child(new ReferenceImpl(t._repo, t._path), e.childName),
            t = t._queryParams.getIndex();
        return new DataEvent(
            e.type,
            this,
            new DataSnapshot(e.snapshotNode, n, t),
            e.prevName
        );
    }
    getEventRunner(e) {
        return 'cancel' === e.getEventType()
            ? () => this.callbackContext.onCancel(e.error)
            : () => this.callbackContext.onValue(e.snapshot, e.prevName);
    }
    matches(e) {
        return (
            e instanceof ChildEventRegistration &&
            this.eventType === e.eventType &&
            (!this.callbackContext ||
                !e.callbackContext ||
                this.callbackContext.matches(e.callbackContext))
        );
    }
    hasAnyCallback() {
        return !!this.callbackContext;
    }
}
function addEventListener(n, e, t, r, i) {
    let o;
    if (
        ('object' == typeof r && ((o = void 0), (i = r)),
        'function' == typeof r && (o = r),
        i && i.onlyOnce)
    ) {
        const a = t;
        i = (e, t) => {
            repoRemoveEventCallbackForQuery(n._repo, n, s), a(e, t);
        };
        (i.userCallback = t.userCallback), (i.context = t.context), (t = i);
    }
    t = new CallbackContext(t, o || void 0);
    const s =
        'value' === e
            ? new ValueEventRegistration(t)
            : new ChildEventRegistration(e, t);
    return (
        repoAddEventCallbackForQuery(n._repo, n, s),
        () => repoRemoveEventCallbackForQuery(n._repo, n, s)
    );
}
function onValue(e, t, n, r) {
    return addEventListener(e, 'value', t, n, r);
}
function onChildAdded(e, t, n, r) {
    return addEventListener(e, 'child_added', t, n, r);
}
function onChildChanged(e, t, n, r) {
    return addEventListener(e, 'child_changed', t, n, r);
}
function onChildMoved(e, t, n, r) {
    return addEventListener(e, 'child_moved', t, n, r);
}
function onChildRemoved(e, t, n, r) {
    return addEventListener(e, 'child_removed', t, n, r);
}
function off(e, t, n) {
    let r = null;
    n = n ? new CallbackContext(n) : null;
    'value' === t
        ? (r = new ValueEventRegistration(n))
        : t && (r = new ChildEventRegistration(t, n)),
        repoRemoveEventCallbackForQuery(e._repo, e, r);
}
class QueryConstraint {}
class QueryEndAtConstraint extends QueryConstraint {
    constructor(e, t) {
        super(), (this._value = e), (this._key = t);
    }
    _apply(e) {
        validateFirebaseDataArg('endAt', this._value, e._path, !0);
        var t = queryParamsEndAt(e._queryParams, this._value, this._key);
        if (
            (validateLimit(t),
            validateQueryEndpoints(t),
            e._queryParams.hasEnd())
        )
            throw new Error(
                'endAt: Starting point was already set (by another call to endAt, endBefore or equalTo).'
            );
        return new QueryImpl(e._repo, e._path, t, e._orderByCalled);
    }
}
function endAt(e, t) {
    return validateKey('endAt', 'key', t, !0), new QueryEndAtConstraint(e, t);
}
class QueryEndBeforeConstraint extends QueryConstraint {
    constructor(e, t) {
        super(), (this._value = e), (this._key = t);
    }
    _apply(e) {
        validateFirebaseDataArg('endBefore', this._value, e._path, !1);
        var t = queryParamsEndBefore(e._queryParams, this._value, this._key);
        if (
            (validateLimit(t),
            validateQueryEndpoints(t),
            e._queryParams.hasEnd())
        )
            throw new Error(
                'endBefore: Starting point was already set (by another call to endAt, endBefore or equalTo).'
            );
        return new QueryImpl(e._repo, e._path, t, e._orderByCalled);
    }
}
function endBefore(e, t) {
    return (
        validateKey('endBefore', 'key', t, !0),
        new QueryEndBeforeConstraint(e, t)
    );
}
class QueryStartAtConstraint extends QueryConstraint {
    constructor(e, t) {
        super(), (this._value = e), (this._key = t);
    }
    _apply(e) {
        validateFirebaseDataArg('startAt', this._value, e._path, !0);
        var t = queryParamsStartAt(e._queryParams, this._value, this._key);
        if (
            (validateLimit(t),
            validateQueryEndpoints(t),
            e._queryParams.hasStart())
        )
            throw new Error(
                'startAt: Starting point was already set (by another call to startAt, startBefore or equalTo).'
            );
        return new QueryImpl(e._repo, e._path, t, e._orderByCalled);
    }
}
function startAt(e = null, t) {
    return (
        validateKey('startAt', 'key', t, !0), new QueryStartAtConstraint(e, t)
    );
}
class QueryStartAfterConstraint extends QueryConstraint {
    constructor(e, t) {
        super(), (this._value = e), (this._key = t);
    }
    _apply(e) {
        validateFirebaseDataArg('startAfter', this._value, e._path, !1);
        var t = queryParamsStartAfter(e._queryParams, this._value, this._key);
        if (
            (validateLimit(t),
            validateQueryEndpoints(t),
            e._queryParams.hasStart())
        )
            throw new Error(
                'startAfter: Starting point was already set (by another call to startAt, startAfter, or equalTo).'
            );
        return new QueryImpl(e._repo, e._path, t, e._orderByCalled);
    }
}
function startAfter(e, t) {
    return (
        validateKey('startAfter', 'key', t, !0),
        new QueryStartAfterConstraint(e, t)
    );
}
class QueryLimitToFirstConstraint extends QueryConstraint {
    constructor(e) {
        super(), (this._limit = e);
    }
    _apply(e) {
        if (e._queryParams.hasLimit())
            throw new Error(
                'limitToFirst: Limit was already set (by another call to limitToFirst or limitToLast).'
            );
        return new QueryImpl(
            e._repo,
            e._path,
            queryParamsLimitToFirst(e._queryParams, this._limit),
            e._orderByCalled
        );
    }
}
function limitToFirst(e) {
    if ('number' != typeof e || Math.floor(e) !== e || e <= 0)
        throw new Error(
            'limitToFirst: First argument must be a positive integer.'
        );
    return new QueryLimitToFirstConstraint(e);
}
class QueryLimitToLastConstraint extends QueryConstraint {
    constructor(e) {
        super(), (this._limit = e);
    }
    _apply(e) {
        if (e._queryParams.hasLimit())
            throw new Error(
                'limitToLast: Limit was already set (by another call to limitToFirst or limitToLast).'
            );
        return new QueryImpl(
            e._repo,
            e._path,
            queryParamsLimitToLast(e._queryParams, this._limit),
            e._orderByCalled
        );
    }
}
function limitToLast(e) {
    if ('number' != typeof e || Math.floor(e) !== e || e <= 0)
        throw new Error(
            'limitToLast: First argument must be a positive integer.'
        );
    return new QueryLimitToLastConstraint(e);
}
class QueryOrderByChildConstraint extends QueryConstraint {
    constructor(e) {
        super(), (this._path = e);
    }
    _apply(e) {
        validateNoPreviousOrderByCall(e, 'orderByChild');
        var t = new Path(this._path);
        if (pathIsEmpty(t))
            throw new Error(
                'orderByChild: cannot pass in empty path. Use orderByValue() instead.'
            );
        (t = new PathIndex(t)), (t = queryParamsOrderBy(e._queryParams, t));
        return (
            validateQueryEndpoints(t), new QueryImpl(e._repo, e._path, t, !0)
        );
    }
}
function orderByChild(e) {
    if ('$key' === e)
        throw new Error(
            'orderByChild: "$key" is invalid.  Use orderByKey() instead.'
        );
    if ('$priority' === e)
        throw new Error(
            'orderByChild: "$priority" is invalid.  Use orderByPriority() instead.'
        );
    if ('$value' === e)
        throw new Error(
            'orderByChild: "$value" is invalid.  Use orderByValue() instead.'
        );
    return (
        validatePathString('orderByChild', 'path', e, !1),
        new QueryOrderByChildConstraint(e)
    );
}
class QueryOrderByKeyConstraint extends QueryConstraint {
    _apply(e) {
        validateNoPreviousOrderByCall(e, 'orderByKey');
        var t = queryParamsOrderBy(e._queryParams, KEY_INDEX);
        return (
            validateQueryEndpoints(t), new QueryImpl(e._repo, e._path, t, !0)
        );
    }
}
function orderByKey() {
    return new QueryOrderByKeyConstraint();
}
class QueryOrderByPriorityConstraint extends QueryConstraint {
    _apply(e) {
        validateNoPreviousOrderByCall(e, 'orderByPriority');
        var t = queryParamsOrderBy(e._queryParams, PRIORITY_INDEX);
        return (
            validateQueryEndpoints(t), new QueryImpl(e._repo, e._path, t, !0)
        );
    }
}
function orderByPriority() {
    return new QueryOrderByPriorityConstraint();
}
class QueryOrderByValueConstraint extends QueryConstraint {
    _apply(e) {
        validateNoPreviousOrderByCall(e, 'orderByValue');
        var t = queryParamsOrderBy(e._queryParams, VALUE_INDEX);
        return (
            validateQueryEndpoints(t), new QueryImpl(e._repo, e._path, t, !0)
        );
    }
}
function orderByValue() {
    return new QueryOrderByValueConstraint();
}
class QueryEqualToValueConstraint extends QueryConstraint {
    constructor(e, t) {
        super(), (this._value = e), (this._key = t);
    }
    _apply(e) {
        if (
            (validateFirebaseDataArg('equalTo', this._value, e._path, !1),
            e._queryParams.hasStart())
        )
            throw new Error(
                'equalTo: Starting point was already set (by another call to startAt/startAfter or equalTo).'
            );
        if (e._queryParams.hasEnd())
            throw new Error(
                'equalTo: Ending point was already set (by another call to endAt/endBefore or equalTo).'
            );
        return new QueryEndAtConstraint(this._value, this._key)._apply(
            new QueryStartAtConstraint(this._value, this._key)._apply(e)
        );
    }
}
function equalTo(e, t) {
    return (
        validateKey('equalTo', 'key', t, !0),
        new QueryEqualToValueConstraint(e, t)
    );
}
function query(e, ...t) {
    let n = getModularInstance(e);
    for (const r of t) n = r._apply(n);
    return n;
}
syncPointSetReferenceConstructor(ReferenceImpl),
    syncTreeSetReferenceConstructor(ReferenceImpl);
const FIREBASE_DATABASE_EMULATOR_HOST_VAR = 'FIREBASE_DATABASE_EMULATOR_HOST',
    repos = {};
let useRestClient = !1;
function repoManagerApplyEmulatorSettings(e, t, n, r) {
    (e.repoInfo_ = new RepoInfo(
        `${t}:${n}`,
        !1,
        e.repoInfo_.namespace,
        e.repoInfo_.webSocketOnly,
        e.repoInfo_.nodeAdmin,
        e.repoInfo_.persistenceKey,
        e.repoInfo_.includeNamespaceInQueryParams
    )),
        r && (e.authTokenProvider_ = r);
}
function repoManagerDatabaseFromApp(e, t, n, r, i) {
    let o = r || e.options.databaseURL;
    void 0 === o &&
        (e.options.projectId ||
            fatal(
                "Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp()."
            ),
        log('Using default host for project ', e.options.projectId),
        (o = `${e.options.projectId}-default-rtdb.firebaseio.com`));
    let s = parseRepoInfo(o, i),
        a = s.repoInfo,
        l,
        h = void 0;
    'undefined' != typeof process &&
        (h = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR]),
        h
            ? ((l = !0),
              (o = `http://${h}?ns=${a.namespace}`),
              (s = parseRepoInfo(o, i)),
              (a = s.repoInfo))
            : (l = !s.repoInfo.secure);
    t =
        i && l
            ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER)
            : new FirebaseAuthTokenProvider(e.name, e.options, t);
    validateUrl('Invalid Firebase Database URL', s),
        pathIsEmpty(s.path) ||
            fatal(
                'Database URL must point to the root of a Firebase Database (not including a child path).'
            );
    n = repoManagerCreateRepo(a, e, t, new AppCheckTokenProvider(e.name, n));
    return new Database(n, e);
}
function repoManagerDeleteRepo(e, t) {
    const n = repos[t];
    (n && n[e.key] === e) ||
        fatal(`Database ${t}(${e.repoInfo_}) has already been deleted.`),
        repoInterrupt(e),
        delete n[e.key];
}
function repoManagerCreateRepo(e, t, n, r) {
    let i = repos[t.name];
    return (
        i || ((i = {}), (repos[t.name] = i)),
        (t = i[e.toURLString()]) &&
            fatal(
                'Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.'
            ),
        (t = new Repo(e, useRestClient, n, r)),
        (i[e.toURLString()] = t)
    );
}
function repoManagerForceRestClient(e) {
    useRestClient = e;
}
class Database {
    constructor(e, t) {
        (this._repoInternal = e),
            (this.app = t),
            (this.type = 'database'),
            (this._instanceStarted = !1);
    }
    get _repo() {
        return (
            this._instanceStarted ||
                (repoStart(
                    this._repoInternal,
                    this.app.options.appId,
                    this.app.options.databaseAuthVariableOverride
                ),
                (this._instanceStarted = !0)),
            this._repoInternal
        );
    }
    get _root() {
        return (
            this._rootInternal ||
                (this._rootInternal = new ReferenceImpl(
                    this._repo,
                    newEmptyPath()
                )),
            this._rootInternal
        );
    }
    _delete() {
        return (
            null !== this._rootInternal &&
                (repoManagerDeleteRepo(this._repo, this.app.name),
                (this._repoInternal = null),
                (this._rootInternal = null)),
            Promise.resolve()
        );
    }
    _checkNotDeleted(e) {
        null === this._rootInternal &&
            fatal('Cannot call ' + e + ' on a deleted database.');
    }
}
function getDatabase(e = getApp(), t) {
    return _getProvider(e, 'database').getImmediate({ identifier: t });
}
function connectDatabaseEmulator(e, t, n, r = {}) {
    (e = getModularInstance(e))._checkNotDeleted('useEmulator'),
        e._instanceStarted &&
            fatal(
                'Cannot call useEmulator() after instance has already been initialized.'
            );
    var i = e._repoInternal;
    let o = void 0;
    i.repoInfo_.nodeAdmin
        ? (r.mockUserToken &&
              fatal(
                  'mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".'
              ),
          (o = new EmulatorTokenProvider(EmulatorTokenProvider.OWNER)))
        : r.mockUserToken &&
          ((e =
              'string' == typeof r.mockUserToken
                  ? r.mockUserToken
                  : createMockUserToken(
                        r.mockUserToken,
                        e.app.options.projectId
                    )),
          (o = new EmulatorTokenProvider(e))),
        repoManagerApplyEmulatorSettings(i, t, n, o);
}
function goOffline(e) {
    (e = getModularInstance(e))._checkNotDeleted('goOffline'),
        repoInterrupt(e._repo);
}
function goOnline(e) {
    (e = getModularInstance(e))._checkNotDeleted('goOnline'),
        repoResume(e._repo);
}
function enableLogging(e, t) {
    enableLogging$1(e, t);
}
function registerDatabase(e) {
    setSDKVersion(SDK_VERSION$1),
        _registerComponent(
            new Component(
                'database',
                (e, { instanceIdentifier: t }) => {
                    return repoManagerDatabaseFromApp(
                        e.getProvider('app').getImmediate(),
                        e.getProvider('auth-internal'),
                        e.getProvider('app-check-internal'),
                        t
                    );
                },
                'PUBLIC'
            ).setMultipleInstances(!0)
        ),
        registerVersion(name, version, e),
        registerVersion(name, version, 'esm2017');
}
const SERVER_TIMESTAMP = { '.sv': 'timestamp' };
function serverTimestamp() {
    return SERVER_TIMESTAMP;
}
function increment(e) {
    return { '.sv': { increment: e } };
}
class TransactionResult {
    constructor(e, t) {
        (this.committed = e), (this.snapshot = t);
    }
    toJSON() {
        return { committed: this.committed, snapshot: this.snapshot.toJSON() };
    }
}
function runTransaction(i, e, t) {
    if (
        ((i = getModularInstance(i)),
        validateWritablePath('Reference.transaction', i._path),
        '.length' === i.key || '.keys' === i.key)
    )
        throw (
            'Reference.transaction failed: ' + i.key + ' is a read-only object.'
        );
    t = null === (n = null == t ? void 0 : t.applyLocally) || void 0 === n || n;
    const o = new Deferred();
    var n = onValue(i, () => {});
    return (
        repoStartTransaction(
            i._repo,
            i._path,
            e,
            (e, t, n) => {
                var r;
                e
                    ? o.reject(e)
                    : ((r = new DataSnapshot(
                          n,
                          new ReferenceImpl(i._repo, i._path),
                          PRIORITY_INDEX
                      )),
                      o.resolve(new TransactionResult(t, r)));
            },
            n,
            t
        ),
        o.promise
    );
}
(PersistentConnection.prototype.simpleListen = function (e, t) {
    this.sendRequest('q', { p: e }, t);
}),
    (PersistentConnection.prototype.echo = function (e, t) {
        this.sendRequest('echo', { d: e }, t);
    });
const hijackHash = function (i) {
        const o = PersistentConnection.prototype.put;
        return (
            (PersistentConnection.prototype.put = function (e, t, n, r) {
                void 0 !== r && (r = i()), o.call(this, e, t, n, r);
            }),
            function () {
                PersistentConnection.prototype.put = o;
            }
        );
    },
    forceRestClient = function (e) {
        repoManagerForceRestClient(e);
    };
registerDatabase();
export {
    DataSnapshot,
    Database,
    OnDisconnect,
    QueryConstraint,
    TransactionResult,
    QueryImpl as _QueryImpl,
    QueryParams as _QueryParams,
    ReferenceImpl as _ReferenceImpl,
    forceRestClient as _TEST_ACCESS_forceRestClient,
    hijackHash as _TEST_ACCESS_hijackHash,
    repoManagerDatabaseFromApp as _repoManagerDatabaseFromApp,
    setSDKVersion as _setSDKVersion,
    validatePathString as _validatePathString,
    validateWritablePath as _validateWritablePath,
    child,
    connectDatabaseEmulator,
    enableLogging,
    endAt,
    endBefore,
    equalTo,
    get,
    getDatabase,
    goOffline,
    goOnline,
    increment,
    limitToFirst,
    limitToLast,
    off,
    onChildAdded,
    onChildChanged,
    onChildMoved,
    onChildRemoved,
    onDisconnect,
    onValue,
    orderByChild,
    orderByKey,
    orderByPriority,
    orderByValue,
    push,
    query,
    ref,
    refFromURL,
    remove,
    runTransaction,
    serverTimestamp,
    set,
    setPriority,
    setWithPriority,
    startAfter,
    startAt,
    update,
};
